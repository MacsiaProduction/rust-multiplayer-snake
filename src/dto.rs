// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `dto.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct GamePlayer {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    id: ::std::option::Option<i32>,
    ip_address: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    role: ::std::option::Option<NodeRole>,
    field_type: ::std::option::Option<PlayerType>,
    score: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GamePlayer {
    fn default() -> &'a GamePlayer {
        <GamePlayer as ::protobuf::Message>::default_instance()
    }
}

impl GamePlayer {
    pub fn new() -> GamePlayer {
        ::std::default::Default::default()
    }

    // required string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 id = 2;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string ip_address = 3;


    pub fn get_ip_address(&self) -> &str {
        match self.ip_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ip_address(&mut self) {
        self.ip_address.clear();
    }

    pub fn has_ip_address(&self) -> bool {
        self.ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_address(&mut self, v: ::std::string::String) {
        self.ip_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_address(&mut self) -> &mut ::std::string::String {
        if self.ip_address.is_none() {
            self.ip_address.set_default();
        }
        self.ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_address(&mut self) -> ::std::string::String {
        self.ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 port = 4;


    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }
    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // required .dto.NodeRole role = 5;


    pub fn get_role(&self) -> NodeRole {
        self.role.unwrap_or(NodeRole::NORMAL)
    }
    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: NodeRole) {
        self.role = ::std::option::Option::Some(v);
    }

    // optional .dto.PlayerType type = 6;


    pub fn get_field_type(&self) -> PlayerType {
        self.field_type.unwrap_or(PlayerType::HUMAN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PlayerType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required int32 score = 7;


    pub fn get_score(&self) -> i32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GamePlayer {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.id.is_none() {
            return false;
        }
        if self.role.is_none() {
            return false;
        }
        if self.score.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.role, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ip_address.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.id {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.ip_address.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.score {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GamePlayer {
        GamePlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GamePlayer| { &m.name },
                |m: &mut GamePlayer| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &GamePlayer| { &m.id },
                |m: &mut GamePlayer| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip_address",
                |m: &GamePlayer| { &m.ip_address },
                |m: &mut GamePlayer| { &mut m.ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &GamePlayer| { &m.port },
                |m: &mut GamePlayer| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NodeRole>>(
                "role",
                |m: &GamePlayer| { &m.role },
                |m: &mut GamePlayer| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PlayerType>>(
                "type",
                |m: &GamePlayer| { &m.field_type },
                |m: &mut GamePlayer| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "score",
                |m: &GamePlayer| { &m.score },
                |m: &mut GamePlayer| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GamePlayer>(
                "GamePlayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GamePlayer {
        static instance: ::protobuf::rt::LazyV2<GamePlayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GamePlayer::new)
    }
}

impl ::protobuf::Clear for GamePlayer {
    fn clear(&mut self) {
        self.name.clear();
        self.id = ::std::option::Option::None;
        self.ip_address.clear();
        self.port = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GamePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GamePlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameConfig {
    // message fields
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    food_static: ::std::option::Option<i32>,
    state_delay_ms: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameConfig {
    fn default() -> &'a GameConfig {
        <GameConfig as ::protobuf::Message>::default_instance()
    }
}

impl GameConfig {
    pub fn new() -> GameConfig {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(40i32)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(30i32)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 food_static = 3;


    pub fn get_food_static(&self) -> i32 {
        self.food_static.unwrap_or(1i32)
    }
    pub fn clear_food_static(&mut self) {
        self.food_static = ::std::option::Option::None;
    }

    pub fn has_food_static(&self) -> bool {
        self.food_static.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food_static(&mut self, v: i32) {
        self.food_static = ::std::option::Option::Some(v);
    }

    // optional int32 state_delay_ms = 5;


    pub fn get_state_delay_ms(&self) -> i32 {
        self.state_delay_ms.unwrap_or(1000i32)
    }
    pub fn clear_state_delay_ms(&mut self) {
        self.state_delay_ms = ::std::option::Option::None;
    }

    pub fn has_state_delay_ms(&self) -> bool {
        self.state_delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_delay_ms(&mut self, v: i32) {
        self.state_delay_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GameConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.food_static = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.state_delay_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.food_static {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state_delay_ms {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.food_static {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.state_delay_ms {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameConfig {
        GameConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &GameConfig| { &m.width },
                |m: &mut GameConfig| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &GameConfig| { &m.height },
                |m: &mut GameConfig| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "food_static",
                |m: &GameConfig| { &m.food_static },
                |m: &mut GameConfig| { &mut m.food_static },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "state_delay_ms",
                |m: &GameConfig| { &m.state_delay_ms },
                |m: &mut GameConfig| { &mut m.state_delay_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameConfig>(
                "GameConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameConfig {
        static instance: ::protobuf::rt::LazyV2<GameConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameConfig::new)
    }
}

impl ::protobuf::Clear for GameConfig {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.food_static = ::std::option::Option::None;
        self.state_delay_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GamePlayers {
    // message fields
    pub players: ::protobuf::RepeatedField<GamePlayer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GamePlayers {
    fn default() -> &'a GamePlayers {
        <GamePlayers as ::protobuf::Message>::default_instance()
    }
}

impl GamePlayers {
    pub fn new() -> GamePlayers {
        ::std::default::Default::default()
    }

    // repeated .dto.GamePlayer players = 1;


    pub fn get_players(&self) -> &[GamePlayer] {
        &self.players
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<GamePlayer>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<GamePlayer> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<GamePlayer> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GamePlayers {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GamePlayers {
        GamePlayers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GamePlayer>>(
                "players",
                |m: &GamePlayers| { &m.players },
                |m: &mut GamePlayers| { &mut m.players },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GamePlayers>(
                "GamePlayers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GamePlayers {
        static instance: ::protobuf::rt::LazyV2<GamePlayers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GamePlayers::new)
    }
}

impl ::protobuf::Clear for GamePlayers {
    fn clear(&mut self) {
        self.players.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GamePlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GamePlayers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameState {
    // message fields
    state_order: ::std::option::Option<i32>,
    pub snakes: ::protobuf::RepeatedField<GameState_Snake>,
    pub foods: ::protobuf::RepeatedField<GameState_Coord>,
    pub players: ::protobuf::SingularPtrField<GamePlayers>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameState {
    fn default() -> &'a GameState {
        <GameState as ::protobuf::Message>::default_instance()
    }
}

impl GameState {
    pub fn new() -> GameState {
        ::std::default::Default::default()
    }

    // required int32 state_order = 1;


    pub fn get_state_order(&self) -> i32 {
        self.state_order.unwrap_or(0)
    }
    pub fn clear_state_order(&mut self) {
        self.state_order = ::std::option::Option::None;
    }

    pub fn has_state_order(&self) -> bool {
        self.state_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_order(&mut self, v: i32) {
        self.state_order = ::std::option::Option::Some(v);
    }

    // repeated .dto.GameState.Snake snakes = 2;


    pub fn get_snakes(&self) -> &[GameState_Snake] {
        &self.snakes
    }
    pub fn clear_snakes(&mut self) {
        self.snakes.clear();
    }

    // Param is passed by value, moved
    pub fn set_snakes(&mut self, v: ::protobuf::RepeatedField<GameState_Snake>) {
        self.snakes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_snakes(&mut self) -> &mut ::protobuf::RepeatedField<GameState_Snake> {
        &mut self.snakes
    }

    // Take field
    pub fn take_snakes(&mut self) -> ::protobuf::RepeatedField<GameState_Snake> {
        ::std::mem::replace(&mut self.snakes, ::protobuf::RepeatedField::new())
    }

    // repeated .dto.GameState.Coord foods = 3;


    pub fn get_foods(&self) -> &[GameState_Coord] {
        &self.foods
    }
    pub fn clear_foods(&mut self) {
        self.foods.clear();
    }

    // Param is passed by value, moved
    pub fn set_foods(&mut self, v: ::protobuf::RepeatedField<GameState_Coord>) {
        self.foods = v;
    }

    // Mutable pointer to the field.
    pub fn mut_foods(&mut self) -> &mut ::protobuf::RepeatedField<GameState_Coord> {
        &mut self.foods
    }

    // Take field
    pub fn take_foods(&mut self) -> ::protobuf::RepeatedField<GameState_Coord> {
        ::std::mem::replace(&mut self.foods, ::protobuf::RepeatedField::new())
    }

    // required .dto.GamePlayers players = 4;


    pub fn get_players(&self) -> &GamePlayers {
        self.players.as_ref().unwrap_or_else(|| <GamePlayers as ::protobuf::Message>::default_instance())
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    pub fn has_players(&self) -> bool {
        self.players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: GamePlayers) {
        self.players = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_players(&mut self) -> &mut GamePlayers {
        if self.players.is_none() {
            self.players.set_default();
        }
        self.players.as_mut().unwrap()
    }

    // Take field
    pub fn take_players(&mut self) -> GamePlayers {
        self.players.take().unwrap_or_else(|| GamePlayers::new())
    }
}

impl ::protobuf::Message for GameState {
    fn is_initialized(&self) -> bool {
        if self.state_order.is_none() {
            return false;
        }
        if self.players.is_none() {
            return false;
        }
        for v in &self.snakes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.foods {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.state_order = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.snakes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.foods)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state_order {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.snakes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.foods {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.players.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state_order {
            os.write_int32(1, v)?;
        }
        for v in &self.snakes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.foods {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.players.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameState {
        GameState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "state_order",
                |m: &GameState| { &m.state_order },
                |m: &mut GameState| { &mut m.state_order },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GameState_Snake>>(
                "snakes",
                |m: &GameState| { &m.snakes },
                |m: &mut GameState| { &mut m.snakes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GameState_Coord>>(
                "foods",
                |m: &GameState| { &m.foods },
                |m: &mut GameState| { &mut m.foods },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GamePlayers>>(
                "players",
                |m: &GameState| { &m.players },
                |m: &mut GameState| { &mut m.players },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameState>(
                "GameState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameState {
        static instance: ::protobuf::rt::LazyV2<GameState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameState::new)
    }
}

impl ::protobuf::Clear for GameState {
    fn clear(&mut self) {
        self.state_order = ::std::option::Option::None;
        self.snakes.clear();
        self.foods.clear();
        self.players.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameState_Coord {
    // message fields
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameState_Coord {
    fn default() -> &'a GameState_Coord {
        <GameState_Coord as ::protobuf::Message>::default_instance()
    }
}

impl GameState_Coord {
    pub fn new() -> GameState_Coord {
        ::std::default::Default::default()
    }

    // optional sint32 x = 1;


    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(0i32)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional sint32 y = 2;


    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(0i32)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GameState_Coord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.x {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameState_Coord {
        GameState_Coord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "x",
                |m: &GameState_Coord| { &m.x },
                |m: &mut GameState_Coord| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "y",
                |m: &GameState_Coord| { &m.y },
                |m: &mut GameState_Coord| { &mut m.y },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameState_Coord>(
                "GameState.Coord",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameState_Coord {
        static instance: ::protobuf::rt::LazyV2<GameState_Coord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameState_Coord::new)
    }
}

impl ::protobuf::Clear for GameState_Coord {
    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameState_Coord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameState_Coord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameState_Snake {
    // message fields
    player_id: ::std::option::Option<i32>,
    pub points: ::protobuf::RepeatedField<GameState_Coord>,
    state: ::std::option::Option<GameState_Snake_SnakeState>,
    head_direction: ::std::option::Option<Direction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameState_Snake {
    fn default() -> &'a GameState_Snake {
        <GameState_Snake as ::protobuf::Message>::default_instance()
    }
}

impl GameState_Snake {
    pub fn new() -> GameState_Snake {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;


    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }
    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // repeated .dto.GameState.Coord points = 2;


    pub fn get_points(&self) -> &[GameState_Coord] {
        &self.points
    }
    pub fn clear_points(&mut self) {
        self.points.clear();
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: ::protobuf::RepeatedField<GameState_Coord>) {
        self.points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_points(&mut self) -> &mut ::protobuf::RepeatedField<GameState_Coord> {
        &mut self.points
    }

    // Take field
    pub fn take_points(&mut self) -> ::protobuf::RepeatedField<GameState_Coord> {
        ::std::mem::replace(&mut self.points, ::protobuf::RepeatedField::new())
    }

    // required .dto.GameState.Snake.SnakeState state = 3;


    pub fn get_state(&self) -> GameState_Snake_SnakeState {
        self.state.unwrap_or(GameState_Snake_SnakeState::ALIVE)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: GameState_Snake_SnakeState) {
        self.state = ::std::option::Option::Some(v);
    }

    // required .dto.Direction head_direction = 4;


    pub fn get_head_direction(&self) -> Direction {
        self.head_direction.unwrap_or(Direction::UP)
    }
    pub fn clear_head_direction(&mut self) {
        self.head_direction = ::std::option::Option::None;
    }

    pub fn has_head_direction(&self) -> bool {
        self.head_direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_head_direction(&mut self, v: Direction) {
        self.head_direction = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GameState_Snake {
    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        if self.state.is_none() {
            return false;
        }
        if self.head_direction.is_none() {
            return false;
        }
        for v in &self.points {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.points)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.head_direction, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.head_direction {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        for v in &self.points {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.state {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.head_direction {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameState_Snake {
        GameState_Snake::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "player_id",
                |m: &GameState_Snake| { &m.player_id },
                |m: &mut GameState_Snake| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GameState_Coord>>(
                "points",
                |m: &GameState_Snake| { &m.points },
                |m: &mut GameState_Snake| { &mut m.points },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GameState_Snake_SnakeState>>(
                "state",
                |m: &GameState_Snake| { &m.state },
                |m: &mut GameState_Snake| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Direction>>(
                "head_direction",
                |m: &GameState_Snake| { &m.head_direction },
                |m: &mut GameState_Snake| { &mut m.head_direction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameState_Snake>(
                "GameState.Snake",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameState_Snake {
        static instance: ::protobuf::rt::LazyV2<GameState_Snake> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameState_Snake::new)
    }
}

impl ::protobuf::Clear for GameState_Snake {
    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.points.clear();
        self.state = ::std::option::Option::None;
        self.head_direction = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameState_Snake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameState_Snake {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GameState_Snake_SnakeState {
    ALIVE = 0,
    ZOMBIE = 1,
}

impl ::protobuf::ProtobufEnum for GameState_Snake_SnakeState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GameState_Snake_SnakeState> {
        match value {
            0 => ::std::option::Option::Some(GameState_Snake_SnakeState::ALIVE),
            1 => ::std::option::Option::Some(GameState_Snake_SnakeState::ZOMBIE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GameState_Snake_SnakeState] = &[
            GameState_Snake_SnakeState::ALIVE,
            GameState_Snake_SnakeState::ZOMBIE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GameState_Snake_SnakeState>("GameState.Snake.SnakeState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GameState_Snake_SnakeState {
}

impl ::std::default::Default for GameState_Snake_SnakeState {
    fn default() -> Self {
        GameState_Snake_SnakeState::ALIVE
    }
}

impl ::protobuf::reflect::ProtobufValue for GameState_Snake_SnakeState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameAnnouncement {
    // message fields
    pub players: ::protobuf::SingularPtrField<GamePlayers>,
    pub config: ::protobuf::SingularPtrField<GameConfig>,
    can_join: ::std::option::Option<bool>,
    game_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameAnnouncement {
    fn default() -> &'a GameAnnouncement {
        <GameAnnouncement as ::protobuf::Message>::default_instance()
    }
}

impl GameAnnouncement {
    pub fn new() -> GameAnnouncement {
        ::std::default::Default::default()
    }

    // required .dto.GamePlayers players = 1;


    pub fn get_players(&self) -> &GamePlayers {
        self.players.as_ref().unwrap_or_else(|| <GamePlayers as ::protobuf::Message>::default_instance())
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    pub fn has_players(&self) -> bool {
        self.players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: GamePlayers) {
        self.players = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_players(&mut self) -> &mut GamePlayers {
        if self.players.is_none() {
            self.players.set_default();
        }
        self.players.as_mut().unwrap()
    }

    // Take field
    pub fn take_players(&mut self) -> GamePlayers {
        self.players.take().unwrap_or_else(|| GamePlayers::new())
    }

    // required .dto.GameConfig config = 2;


    pub fn get_config(&self) -> &GameConfig {
        self.config.as_ref().unwrap_or_else(|| <GameConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: GameConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut GameConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> GameConfig {
        self.config.take().unwrap_or_else(|| GameConfig::new())
    }

    // optional bool can_join = 3;


    pub fn get_can_join(&self) -> bool {
        self.can_join.unwrap_or(true)
    }
    pub fn clear_can_join(&mut self) {
        self.can_join = ::std::option::Option::None;
    }

    pub fn has_can_join(&self) -> bool {
        self.can_join.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_join(&mut self, v: bool) {
        self.can_join = ::std::option::Option::Some(v);
    }

    // required string game_name = 4;


    pub fn get_game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_name(&mut self) {
        self.game_name.clear();
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name.set_default();
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GameAnnouncement {
    fn is_initialized(&self) -> bool {
        if self.players.is_none() {
            return false;
        }
        if self.config.is_none() {
            return false;
        }
        if self.game_name.is_none() {
            return false;
        }
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.players)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_join = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.players.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.can_join {
            my_size += 2;
        }
        if let Some(ref v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.players.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.can_join {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.game_name.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameAnnouncement {
        GameAnnouncement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GamePlayers>>(
                "players",
                |m: &GameAnnouncement| { &m.players },
                |m: &mut GameAnnouncement| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GameConfig>>(
                "config",
                |m: &GameAnnouncement| { &m.config },
                |m: &mut GameAnnouncement| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_join",
                |m: &GameAnnouncement| { &m.can_join },
                |m: &mut GameAnnouncement| { &mut m.can_join },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_name",
                |m: &GameAnnouncement| { &m.game_name },
                |m: &mut GameAnnouncement| { &mut m.game_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameAnnouncement>(
                "GameAnnouncement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameAnnouncement {
        static instance: ::protobuf::rt::LazyV2<GameAnnouncement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameAnnouncement::new)
    }
}

impl ::protobuf::Clear for GameAnnouncement {
    fn clear(&mut self) {
        self.players.clear();
        self.config.clear();
        self.can_join = ::std::option::Option::None;
        self.game_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameAnnouncement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameAnnouncement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameMessage {
    // message fields
    msg_seq: ::std::option::Option<i64>,
    sender_id: ::std::option::Option<i32>,
    receiver_id: ::std::option::Option<i32>,
    // message oneof groups
    pub Type: ::std::option::Option<GameMessage_oneof_Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameMessage {
    fn default() -> &'a GameMessage {
        <GameMessage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GameMessage_oneof_Type {
    ping(GameMessage_PingMsg),
    steer(GameMessage_SteerMsg),
    ack(GameMessage_AckMsg),
    state(GameMessage_StateMsg),
    announcement(GameMessage_AnnouncementMsg),
    join(GameMessage_JoinMsg),
    error(GameMessage_ErrorMsg),
    role_change(GameMessage_RoleChangeMsg),
    discover(GameMessage_DiscoverMsg),
}

impl GameMessage {
    pub fn new() -> GameMessage {
        ::std::default::Default::default()
    }

    // required int64 msg_seq = 1;


    pub fn get_msg_seq(&self) -> i64 {
        self.msg_seq.unwrap_or(0)
    }
    pub fn clear_msg_seq(&mut self) {
        self.msg_seq = ::std::option::Option::None;
    }

    pub fn has_msg_seq(&self) -> bool {
        self.msg_seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_seq(&mut self, v: i64) {
        self.msg_seq = ::std::option::Option::Some(v);
    }

    // optional int32 sender_id = 10;


    pub fn get_sender_id(&self) -> i32 {
        self.sender_id.unwrap_or(0)
    }
    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: i32) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional int32 receiver_id = 11;


    pub fn get_receiver_id(&self) -> i32 {
        self.receiver_id.unwrap_or(0)
    }
    pub fn clear_receiver_id(&mut self) {
        self.receiver_id = ::std::option::Option::None;
    }

    pub fn has_receiver_id(&self) -> bool {
        self.receiver_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_id(&mut self, v: i32) {
        self.receiver_id = ::std::option::Option::Some(v);
    }

    // optional .dto.GameMessage.PingMsg ping = 2;


    pub fn get_ping(&self) -> &GameMessage_PingMsg {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::ping(ref v)) => v,
            _ => <GameMessage_PingMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ping(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: GameMessage_PingMsg) {
        self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut GameMessage_PingMsg {
        if let ::std::option::Option::Some(GameMessage_oneof_Type::ping(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::ping(GameMessage_PingMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> GameMessage_PingMsg {
        if self.has_ping() {
            match self.Type.take() {
                ::std::option::Option::Some(GameMessage_oneof_Type::ping(v)) => v,
                _ => panic!(),
            }
        } else {
            GameMessage_PingMsg::new()
        }
    }

    // optional .dto.GameMessage.SteerMsg steer = 3;


    pub fn get_steer(&self) -> &GameMessage_SteerMsg {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::steer(ref v)) => v,
            _ => <GameMessage_SteerMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_steer(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_steer(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::steer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_steer(&mut self, v: GameMessage_SteerMsg) {
        self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::steer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_steer(&mut self) -> &mut GameMessage_SteerMsg {
        if let ::std::option::Option::Some(GameMessage_oneof_Type::steer(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::steer(GameMessage_SteerMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::steer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_steer(&mut self) -> GameMessage_SteerMsg {
        if self.has_steer() {
            match self.Type.take() {
                ::std::option::Option::Some(GameMessage_oneof_Type::steer(v)) => v,
                _ => panic!(),
            }
        } else {
            GameMessage_SteerMsg::new()
        }
    }

    // optional .dto.GameMessage.AckMsg ack = 4;


    pub fn get_ack(&self) -> &GameMessage_AckMsg {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::ack(ref v)) => v,
            _ => <GameMessage_AckMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ack(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_ack(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::ack(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ack(&mut self, v: GameMessage_AckMsg) {
        self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::ack(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ack(&mut self) -> &mut GameMessage_AckMsg {
        if let ::std::option::Option::Some(GameMessage_oneof_Type::ack(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::ack(GameMessage_AckMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::ack(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ack(&mut self) -> GameMessage_AckMsg {
        if self.has_ack() {
            match self.Type.take() {
                ::std::option::Option::Some(GameMessage_oneof_Type::ack(v)) => v,
                _ => panic!(),
            }
        } else {
            GameMessage_AckMsg::new()
        }
    }

    // optional .dto.GameMessage.StateMsg state = 5;


    pub fn get_state(&self) -> &GameMessage_StateMsg {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::state(ref v)) => v,
            _ => <GameMessage_StateMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_state(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: GameMessage_StateMsg) {
        self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_state(&mut self) -> &mut GameMessage_StateMsg {
        if let ::std::option::Option::Some(GameMessage_oneof_Type::state(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::state(GameMessage_StateMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_state(&mut self) -> GameMessage_StateMsg {
        if self.has_state() {
            match self.Type.take() {
                ::std::option::Option::Some(GameMessage_oneof_Type::state(v)) => v,
                _ => panic!(),
            }
        } else {
            GameMessage_StateMsg::new()
        }
    }

    // optional .dto.GameMessage.AnnouncementMsg announcement = 6;


    pub fn get_announcement(&self) -> &GameMessage_AnnouncementMsg {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::announcement(ref v)) => v,
            _ => <GameMessage_AnnouncementMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_announcement(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_announcement(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::announcement(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_announcement(&mut self, v: GameMessage_AnnouncementMsg) {
        self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::announcement(v))
    }

    // Mutable pointer to the field.
    pub fn mut_announcement(&mut self) -> &mut GameMessage_AnnouncementMsg {
        if let ::std::option::Option::Some(GameMessage_oneof_Type::announcement(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::announcement(GameMessage_AnnouncementMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::announcement(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_announcement(&mut self) -> GameMessage_AnnouncementMsg {
        if self.has_announcement() {
            match self.Type.take() {
                ::std::option::Option::Some(GameMessage_oneof_Type::announcement(v)) => v,
                _ => panic!(),
            }
        } else {
            GameMessage_AnnouncementMsg::new()
        }
    }

    // optional .dto.GameMessage.JoinMsg join = 7;


    pub fn get_join(&self) -> &GameMessage_JoinMsg {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::join(ref v)) => v,
            _ => <GameMessage_JoinMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_join(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_join(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::join(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_join(&mut self, v: GameMessage_JoinMsg) {
        self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::join(v))
    }

    // Mutable pointer to the field.
    pub fn mut_join(&mut self) -> &mut GameMessage_JoinMsg {
        if let ::std::option::Option::Some(GameMessage_oneof_Type::join(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::join(GameMessage_JoinMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::join(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_join(&mut self) -> GameMessage_JoinMsg {
        if self.has_join() {
            match self.Type.take() {
                ::std::option::Option::Some(GameMessage_oneof_Type::join(v)) => v,
                _ => panic!(),
            }
        } else {
            GameMessage_JoinMsg::new()
        }
    }

    // optional .dto.GameMessage.ErrorMsg error = 8;


    pub fn get_error(&self) -> &GameMessage_ErrorMsg {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::error(ref v)) => v,
            _ => <GameMessage_ErrorMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_error(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: GameMessage_ErrorMsg) {
        self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut GameMessage_ErrorMsg {
        if let ::std::option::Option::Some(GameMessage_oneof_Type::error(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::error(GameMessage_ErrorMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> GameMessage_ErrorMsg {
        if self.has_error() {
            match self.Type.take() {
                ::std::option::Option::Some(GameMessage_oneof_Type::error(v)) => v,
                _ => panic!(),
            }
        } else {
            GameMessage_ErrorMsg::new()
        }
    }

    // optional .dto.GameMessage.RoleChangeMsg role_change = 9;


    pub fn get_role_change(&self) -> &GameMessage_RoleChangeMsg {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::role_change(ref v)) => v,
            _ => <GameMessage_RoleChangeMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_role_change(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_role_change(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::role_change(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_role_change(&mut self, v: GameMessage_RoleChangeMsg) {
        self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::role_change(v))
    }

    // Mutable pointer to the field.
    pub fn mut_role_change(&mut self) -> &mut GameMessage_RoleChangeMsg {
        if let ::std::option::Option::Some(GameMessage_oneof_Type::role_change(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::role_change(GameMessage_RoleChangeMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::role_change(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_role_change(&mut self) -> GameMessage_RoleChangeMsg {
        if self.has_role_change() {
            match self.Type.take() {
                ::std::option::Option::Some(GameMessage_oneof_Type::role_change(v)) => v,
                _ => panic!(),
            }
        } else {
            GameMessage_RoleChangeMsg::new()
        }
    }

    // optional .dto.GameMessage.DiscoverMsg discover = 12;


    pub fn get_discover(&self) -> &GameMessage_DiscoverMsg {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::discover(ref v)) => v,
            _ => <GameMessage_DiscoverMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_discover(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_discover(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::discover(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_discover(&mut self, v: GameMessage_DiscoverMsg) {
        self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::discover(v))
    }

    // Mutable pointer to the field.
    pub fn mut_discover(&mut self) -> &mut GameMessage_DiscoverMsg {
        if let ::std::option::Option::Some(GameMessage_oneof_Type::discover(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::discover(GameMessage_DiscoverMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(GameMessage_oneof_Type::discover(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_discover(&mut self) -> GameMessage_DiscoverMsg {
        if self.has_discover() {
            match self.Type.take() {
                ::std::option::Option::Some(GameMessage_oneof_Type::discover(v)) => v,
                _ => panic!(),
            }
        } else {
            GameMessage_DiscoverMsg::new()
        }
    }
}

impl ::protobuf::Message for GameMessage {
    fn is_initialized(&self) -> bool {
        if self.msg_seq.is_none() {
            return false;
        }
        if let Some(GameMessage_oneof_Type::ping(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GameMessage_oneof_Type::steer(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GameMessage_oneof_Type::ack(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GameMessage_oneof_Type::state(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GameMessage_oneof_Type::announcement(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GameMessage_oneof_Type::join(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GameMessage_oneof_Type::error(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GameMessage_oneof_Type::role_change(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GameMessage_oneof_Type::discover(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.msg_seq = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sender_id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.receiver_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::ping(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::steer(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::ack(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::state(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::announcement(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::join(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::error(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::role_change(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = ::std::option::Option::Some(GameMessage_oneof_Type::discover(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msg_seq {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sender_id {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.receiver_id {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.Type {
            match v {
                &GameMessage_oneof_Type::ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GameMessage_oneof_Type::steer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GameMessage_oneof_Type::ack(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GameMessage_oneof_Type::state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GameMessage_oneof_Type::announcement(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GameMessage_oneof_Type::join(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GameMessage_oneof_Type::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GameMessage_oneof_Type::role_change(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GameMessage_oneof_Type::discover(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msg_seq {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.receiver_id {
            os.write_int32(11, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.Type {
            match v {
                &GameMessage_oneof_Type::ping(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GameMessage_oneof_Type::steer(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GameMessage_oneof_Type::ack(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GameMessage_oneof_Type::state(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GameMessage_oneof_Type::announcement(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GameMessage_oneof_Type::join(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GameMessage_oneof_Type::error(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GameMessage_oneof_Type::role_change(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GameMessage_oneof_Type::discover(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameMessage {
        GameMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "msg_seq",
                |m: &GameMessage| { &m.msg_seq },
                |m: &mut GameMessage| { &mut m.msg_seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sender_id",
                |m: &GameMessage| { &m.sender_id },
                |m: &mut GameMessage| { &mut m.sender_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "receiver_id",
                |m: &GameMessage| { &m.receiver_id },
                |m: &mut GameMessage| { &mut m.receiver_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GameMessage_PingMsg>(
                "ping",
                GameMessage::has_ping,
                GameMessage::get_ping,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GameMessage_SteerMsg>(
                "steer",
                GameMessage::has_steer,
                GameMessage::get_steer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GameMessage_AckMsg>(
                "ack",
                GameMessage::has_ack,
                GameMessage::get_ack,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GameMessage_StateMsg>(
                "state",
                GameMessage::has_state,
                GameMessage::get_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GameMessage_AnnouncementMsg>(
                "announcement",
                GameMessage::has_announcement,
                GameMessage::get_announcement,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GameMessage_JoinMsg>(
                "join",
                GameMessage::has_join,
                GameMessage::get_join,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GameMessage_ErrorMsg>(
                "error",
                GameMessage::has_error,
                GameMessage::get_error,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GameMessage_RoleChangeMsg>(
                "role_change",
                GameMessage::has_role_change,
                GameMessage::get_role_change,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GameMessage_DiscoverMsg>(
                "discover",
                GameMessage::has_discover,
                GameMessage::get_discover,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameMessage>(
                "GameMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameMessage {
        static instance: ::protobuf::rt::LazyV2<GameMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameMessage::new)
    }
}

impl ::protobuf::Clear for GameMessage {
    fn clear(&mut self) {
        self.msg_seq = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.receiver_id = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameMessage_PingMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameMessage_PingMsg {
    fn default() -> &'a GameMessage_PingMsg {
        <GameMessage_PingMsg as ::protobuf::Message>::default_instance()
    }
}

impl GameMessage_PingMsg {
    pub fn new() -> GameMessage_PingMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GameMessage_PingMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameMessage_PingMsg {
        GameMessage_PingMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameMessage_PingMsg>(
                "GameMessage.PingMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameMessage_PingMsg {
        static instance: ::protobuf::rt::LazyV2<GameMessage_PingMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameMessage_PingMsg::new)
    }
}

impl ::protobuf::Clear for GameMessage_PingMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameMessage_PingMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage_PingMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameMessage_SteerMsg {
    // message fields
    direction: ::std::option::Option<Direction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameMessage_SteerMsg {
    fn default() -> &'a GameMessage_SteerMsg {
        <GameMessage_SteerMsg as ::protobuf::Message>::default_instance()
    }
}

impl GameMessage_SteerMsg {
    pub fn new() -> GameMessage_SteerMsg {
        ::std::default::Default::default()
    }

    // required .dto.Direction direction = 1;


    pub fn get_direction(&self) -> Direction {
        self.direction.unwrap_or(Direction::UP)
    }
    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: Direction) {
        self.direction = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GameMessage_SteerMsg {
    fn is_initialized(&self) -> bool {
        if self.direction.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.direction {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameMessage_SteerMsg {
        GameMessage_SteerMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Direction>>(
                "direction",
                |m: &GameMessage_SteerMsg| { &m.direction },
                |m: &mut GameMessage_SteerMsg| { &mut m.direction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameMessage_SteerMsg>(
                "GameMessage.SteerMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameMessage_SteerMsg {
        static instance: ::protobuf::rt::LazyV2<GameMessage_SteerMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameMessage_SteerMsg::new)
    }
}

impl ::protobuf::Clear for GameMessage_SteerMsg {
    fn clear(&mut self) {
        self.direction = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameMessage_SteerMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage_SteerMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameMessage_AckMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameMessage_AckMsg {
    fn default() -> &'a GameMessage_AckMsg {
        <GameMessage_AckMsg as ::protobuf::Message>::default_instance()
    }
}

impl GameMessage_AckMsg {
    pub fn new() -> GameMessage_AckMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GameMessage_AckMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameMessage_AckMsg {
        GameMessage_AckMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameMessage_AckMsg>(
                "GameMessage.AckMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameMessage_AckMsg {
        static instance: ::protobuf::rt::LazyV2<GameMessage_AckMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameMessage_AckMsg::new)
    }
}

impl ::protobuf::Clear for GameMessage_AckMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameMessage_AckMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage_AckMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameMessage_StateMsg {
    // message fields
    pub state: ::protobuf::SingularPtrField<GameState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameMessage_StateMsg {
    fn default() -> &'a GameMessage_StateMsg {
        <GameMessage_StateMsg as ::protobuf::Message>::default_instance()
    }
}

impl GameMessage_StateMsg {
    pub fn new() -> GameMessage_StateMsg {
        ::std::default::Default::default()
    }

    // required .dto.GameState state = 1;


    pub fn get_state(&self) -> &GameState {
        self.state.as_ref().unwrap_or_else(|| <GameState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: GameState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut GameState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> GameState {
        self.state.take().unwrap_or_else(|| GameState::new())
    }
}

impl ::protobuf::Message for GameMessage_StateMsg {
    fn is_initialized(&self) -> bool {
        if self.state.is_none() {
            return false;
        }
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameMessage_StateMsg {
        GameMessage_StateMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GameState>>(
                "state",
                |m: &GameMessage_StateMsg| { &m.state },
                |m: &mut GameMessage_StateMsg| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameMessage_StateMsg>(
                "GameMessage.StateMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameMessage_StateMsg {
        static instance: ::protobuf::rt::LazyV2<GameMessage_StateMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameMessage_StateMsg::new)
    }
}

impl ::protobuf::Clear for GameMessage_StateMsg {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameMessage_StateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage_StateMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameMessage_AnnouncementMsg {
    // message fields
    pub games: ::protobuf::RepeatedField<GameAnnouncement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameMessage_AnnouncementMsg {
    fn default() -> &'a GameMessage_AnnouncementMsg {
        <GameMessage_AnnouncementMsg as ::protobuf::Message>::default_instance()
    }
}

impl GameMessage_AnnouncementMsg {
    pub fn new() -> GameMessage_AnnouncementMsg {
        ::std::default::Default::default()
    }

    // repeated .dto.GameAnnouncement games = 1;


    pub fn get_games(&self) -> &[GameAnnouncement] {
        &self.games
    }
    pub fn clear_games(&mut self) {
        self.games.clear();
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: ::protobuf::RepeatedField<GameAnnouncement>) {
        self.games = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games(&mut self) -> &mut ::protobuf::RepeatedField<GameAnnouncement> {
        &mut self.games
    }

    // Take field
    pub fn take_games(&mut self) -> ::protobuf::RepeatedField<GameAnnouncement> {
        ::std::mem::replace(&mut self.games, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GameMessage_AnnouncementMsg {
    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.games {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameMessage_AnnouncementMsg {
        GameMessage_AnnouncementMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GameAnnouncement>>(
                "games",
                |m: &GameMessage_AnnouncementMsg| { &m.games },
                |m: &mut GameMessage_AnnouncementMsg| { &mut m.games },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameMessage_AnnouncementMsg>(
                "GameMessage.AnnouncementMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameMessage_AnnouncementMsg {
        static instance: ::protobuf::rt::LazyV2<GameMessage_AnnouncementMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameMessage_AnnouncementMsg::new)
    }
}

impl ::protobuf::Clear for GameMessage_AnnouncementMsg {
    fn clear(&mut self) {
        self.games.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameMessage_AnnouncementMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage_AnnouncementMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameMessage_DiscoverMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameMessage_DiscoverMsg {
    fn default() -> &'a GameMessage_DiscoverMsg {
        <GameMessage_DiscoverMsg as ::protobuf::Message>::default_instance()
    }
}

impl GameMessage_DiscoverMsg {
    pub fn new() -> GameMessage_DiscoverMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GameMessage_DiscoverMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameMessage_DiscoverMsg {
        GameMessage_DiscoverMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameMessage_DiscoverMsg>(
                "GameMessage.DiscoverMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameMessage_DiscoverMsg {
        static instance: ::protobuf::rt::LazyV2<GameMessage_DiscoverMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameMessage_DiscoverMsg::new)
    }
}

impl ::protobuf::Clear for GameMessage_DiscoverMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameMessage_DiscoverMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage_DiscoverMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameMessage_JoinMsg {
    // message fields
    player_type: ::std::option::Option<PlayerType>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    game_name: ::protobuf::SingularField<::std::string::String>,
    requested_role: ::std::option::Option<NodeRole>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameMessage_JoinMsg {
    fn default() -> &'a GameMessage_JoinMsg {
        <GameMessage_JoinMsg as ::protobuf::Message>::default_instance()
    }
}

impl GameMessage_JoinMsg {
    pub fn new() -> GameMessage_JoinMsg {
        ::std::default::Default::default()
    }

    // optional .dto.PlayerType player_type = 1;


    pub fn get_player_type(&self) -> PlayerType {
        self.player_type.unwrap_or(PlayerType::HUMAN)
    }
    pub fn clear_player_type(&mut self) {
        self.player_type = ::std::option::Option::None;
    }

    pub fn has_player_type(&self) -> bool {
        self.player_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_type(&mut self, v: PlayerType) {
        self.player_type = ::std::option::Option::Some(v);
    }

    // required string player_name = 3;


    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string game_name = 4;


    pub fn get_game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_name(&mut self) {
        self.game_name.clear();
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name.set_default();
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .dto.NodeRole requested_role = 5;


    pub fn get_requested_role(&self) -> NodeRole {
        self.requested_role.unwrap_or(NodeRole::NORMAL)
    }
    pub fn clear_requested_role(&mut self) {
        self.requested_role = ::std::option::Option::None;
    }

    pub fn has_requested_role(&self) -> bool {
        self.requested_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_role(&mut self, v: NodeRole) {
        self.requested_role = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GameMessage_JoinMsg {
    fn is_initialized(&self) -> bool {
        if self.player_name.is_none() {
            return false;
        }
        if self.game_name.is_none() {
            return false;
        }
        if self.requested_role.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.player_type, 1, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_name)?;
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.requested_role, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.requested_role {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.game_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.requested_role {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameMessage_JoinMsg {
        GameMessage_JoinMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PlayerType>>(
                "player_type",
                |m: &GameMessage_JoinMsg| { &m.player_type },
                |m: &mut GameMessage_JoinMsg| { &mut m.player_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "player_name",
                |m: &GameMessage_JoinMsg| { &m.player_name },
                |m: &mut GameMessage_JoinMsg| { &mut m.player_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_name",
                |m: &GameMessage_JoinMsg| { &m.game_name },
                |m: &mut GameMessage_JoinMsg| { &mut m.game_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NodeRole>>(
                "requested_role",
                |m: &GameMessage_JoinMsg| { &m.requested_role },
                |m: &mut GameMessage_JoinMsg| { &mut m.requested_role },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameMessage_JoinMsg>(
                "GameMessage.JoinMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameMessage_JoinMsg {
        static instance: ::protobuf::rt::LazyV2<GameMessage_JoinMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameMessage_JoinMsg::new)
    }
}

impl ::protobuf::Clear for GameMessage_JoinMsg {
    fn clear(&mut self) {
        self.player_type = ::std::option::Option::None;
        self.player_name.clear();
        self.game_name.clear();
        self.requested_role = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameMessage_JoinMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage_JoinMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameMessage_ErrorMsg {
    // message fields
    error_message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameMessage_ErrorMsg {
    fn default() -> &'a GameMessage_ErrorMsg {
        <GameMessage_ErrorMsg as ::protobuf::Message>::default_instance()
    }
}

impl GameMessage_ErrorMsg {
    pub fn new() -> GameMessage_ErrorMsg {
        ::std::default::Default::default()
    }

    // required string error_message = 1;


    pub fn get_error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message.set_default();
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GameMessage_ErrorMsg {
    fn is_initialized(&self) -> bool {
        if self.error_message.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error_message.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameMessage_ErrorMsg {
        GameMessage_ErrorMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_message",
                |m: &GameMessage_ErrorMsg| { &m.error_message },
                |m: &mut GameMessage_ErrorMsg| { &mut m.error_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameMessage_ErrorMsg>(
                "GameMessage.ErrorMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameMessage_ErrorMsg {
        static instance: ::protobuf::rt::LazyV2<GameMessage_ErrorMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameMessage_ErrorMsg::new)
    }
}

impl ::protobuf::Clear for GameMessage_ErrorMsg {
    fn clear(&mut self) {
        self.error_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameMessage_ErrorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage_ErrorMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameMessage_RoleChangeMsg {
    // message fields
    sender_role: ::std::option::Option<NodeRole>,
    receiver_role: ::std::option::Option<NodeRole>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameMessage_RoleChangeMsg {
    fn default() -> &'a GameMessage_RoleChangeMsg {
        <GameMessage_RoleChangeMsg as ::protobuf::Message>::default_instance()
    }
}

impl GameMessage_RoleChangeMsg {
    pub fn new() -> GameMessage_RoleChangeMsg {
        ::std::default::Default::default()
    }

    // optional .dto.NodeRole sender_role = 1;


    pub fn get_sender_role(&self) -> NodeRole {
        self.sender_role.unwrap_or(NodeRole::NORMAL)
    }
    pub fn clear_sender_role(&mut self) {
        self.sender_role = ::std::option::Option::None;
    }

    pub fn has_sender_role(&self) -> bool {
        self.sender_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_role(&mut self, v: NodeRole) {
        self.sender_role = ::std::option::Option::Some(v);
    }

    // optional .dto.NodeRole receiver_role = 2;


    pub fn get_receiver_role(&self) -> NodeRole {
        self.receiver_role.unwrap_or(NodeRole::NORMAL)
    }
    pub fn clear_receiver_role(&mut self) {
        self.receiver_role = ::std::option::Option::None;
    }

    pub fn has_receiver_role(&self) -> bool {
        self.receiver_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_role(&mut self, v: NodeRole) {
        self.receiver_role = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GameMessage_RoleChangeMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.sender_role, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.receiver_role, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sender_role {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.receiver_role {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sender_role {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.receiver_role {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameMessage_RoleChangeMsg {
        GameMessage_RoleChangeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NodeRole>>(
                "sender_role",
                |m: &GameMessage_RoleChangeMsg| { &m.sender_role },
                |m: &mut GameMessage_RoleChangeMsg| { &mut m.sender_role },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NodeRole>>(
                "receiver_role",
                |m: &GameMessage_RoleChangeMsg| { &m.receiver_role },
                |m: &mut GameMessage_RoleChangeMsg| { &mut m.receiver_role },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameMessage_RoleChangeMsg>(
                "GameMessage.RoleChangeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameMessage_RoleChangeMsg {
        static instance: ::protobuf::rt::LazyV2<GameMessage_RoleChangeMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameMessage_RoleChangeMsg::new)
    }
}

impl ::protobuf::Clear for GameMessage_RoleChangeMsg {
    fn clear(&mut self) {
        self.sender_role = ::std::option::Option::None;
        self.receiver_role = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameMessage_RoleChangeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage_RoleChangeMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NodeRole {
    NORMAL = 0,
    MASTER = 1,
    DEPUTY = 2,
    VIEWER = 3,
}

impl ::protobuf::ProtobufEnum for NodeRole {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NodeRole> {
        match value {
            0 => ::std::option::Option::Some(NodeRole::NORMAL),
            1 => ::std::option::Option::Some(NodeRole::MASTER),
            2 => ::std::option::Option::Some(NodeRole::DEPUTY),
            3 => ::std::option::Option::Some(NodeRole::VIEWER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NodeRole] = &[
            NodeRole::NORMAL,
            NodeRole::MASTER,
            NodeRole::DEPUTY,
            NodeRole::VIEWER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NodeRole>("NodeRole", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NodeRole {
}

impl ::std::default::Default for NodeRole {
    fn default() -> Self {
        NodeRole::NORMAL
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeRole {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PlayerType {
    HUMAN = 0,
    ROBOT = 1,
}

impl ::protobuf::ProtobufEnum for PlayerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PlayerType> {
        match value {
            0 => ::std::option::Option::Some(PlayerType::HUMAN),
            1 => ::std::option::Option::Some(PlayerType::ROBOT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PlayerType] = &[
            PlayerType::HUMAN,
            PlayerType::ROBOT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PlayerType>("PlayerType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PlayerType {
}

impl ::std::default::Default for PlayerType {
    fn default() -> Self {
        PlayerType::HUMAN
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Direction {
    UP = 1,
    DOWN = 2,
    LEFT = 3,
    RIGHT = 4,
}

impl ::protobuf::ProtobufEnum for Direction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Direction> {
        match value {
            1 => ::std::option::Option::Some(Direction::UP),
            2 => ::std::option::Option::Some(Direction::DOWN),
            3 => ::std::option::Option::Some(Direction::LEFT),
            4 => ::std::option::Option::Some(Direction::RIGHT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Direction] = &[
            Direction::UP,
            Direction::DOWN,
            Direction::LEFT,
            Direction::RIGHT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Direction>("Direction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Direction {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Direction {
    fn default() -> Self {
        Direction::UP
    }
}

impl ::protobuf::reflect::ProtobufValue for Direction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tdto.proto\x12\x03dto\"\xc8\x01\n\nGamePlayer\x12\x12\n\x04name\x18\
    \x01\x20\x02(\tR\x04name\x12\x0e\n\x02id\x18\x02\x20\x02(\x05R\x02id\x12\
    \x1d\n\nip_address\x18\x03\x20\x01(\tR\tipAddress\x12\x12\n\x04port\x18\
    \x04\x20\x01(\x05R\x04port\x12!\n\x04role\x18\x05\x20\x02(\x0e2\r.dto.No\
    deRoleR\x04role\x12*\n\x04type\x18\x06\x20\x01(\x0e2\x0f.dto.PlayerType:\
    \x05HUMANR\x04type\x12\x14\n\x05score\x18\x07\x20\x02(\x05R\x05score\"\
    \x92\x01\n\nGameConfig\x12\x18\n\x05width\x18\x01\x20\x01(\x05:\x0240R\
    \x05width\x12\x1a\n\x06height\x18\x02\x20\x01(\x05:\x0230R\x06height\x12\
    \"\n\x0bfood_static\x18\x03\x20\x01(\x05:\x011R\nfoodStatic\x12*\n\x0est\
    ate_delay_ms\x18\x05\x20\x01(\x05:\x041000R\x0cstateDelayMs\"8\n\x0bGame\
    Players\x12)\n\x07players\x18\x01\x20\x03(\x0b2\x0f.dto.GamePlayerR\x07p\
    layers\"\xcc\x03\n\tGameState\x12\x1f\n\x0bstate_order\x18\x01\x20\x02(\
    \x05R\nstateOrder\x12,\n\x06snakes\x18\x02\x20\x03(\x0b2\x14.dto.GameSta\
    te.SnakeR\x06snakes\x12*\n\x05foods\x18\x03\x20\x03(\x0b2\x14.dto.GameSt\
    ate.CoordR\x05foods\x12*\n\x07players\x18\x04\x20\x02(\x0b2\x10.dto.Game\
    PlayersR\x07players\x1a)\n\x05Coord\x12\x0f\n\x01x\x18\x01\x20\x01(\x11:\
    \x010R\x01x\x12\x0f\n\x01y\x18\x02\x20\x01(\x11:\x010R\x01y\x1a\xec\x01\
    \n\x05Snake\x12\x1b\n\tplayer_id\x18\x01\x20\x02(\x05R\x08playerId\x12,\
    \n\x06points\x18\x02\x20\x03(\x0b2\x14.dto.GameState.CoordR\x06points\
    \x12<\n\x05state\x18\x03\x20\x02(\x0e2\x1f.dto.GameState.Snake.SnakeStat\
    e:\x05ALIVER\x05state\x125\n\x0ehead_direction\x18\x04\x20\x02(\x0e2\x0e\
    .dto.DirectionR\rheadDirection\"#\n\nSnakeState\x12\t\n\x05ALIVE\x10\0\
    \x12\n\n\x06ZOMBIE\x10\x01\"\xa5\x01\n\x10GameAnnouncement\x12*\n\x07pla\
    yers\x18\x01\x20\x02(\x0b2\x10.dto.GamePlayersR\x07players\x12'\n\x06con\
    fig\x18\x02\x20\x02(\x0b2\x0f.dto.GameConfigR\x06config\x12\x1f\n\x08can\
    _join\x18\x03\x20\x01(\x08:\x04trueR\x07canJoin\x12\x1b\n\tgame_name\x18\
    \x04\x20\x02(\tR\x08gameName\"\x88\t\n\x0bGameMessage\x12\x17\n\x07msg_s\
    eq\x18\x01\x20\x02(\x03R\x06msgSeq\x12\x1b\n\tsender_id\x18\n\x20\x01(\
    \x05R\x08senderId\x12\x1f\n\x0breceiver_id\x18\x0b\x20\x01(\x05R\nreceiv\
    erId\x12.\n\x04ping\x18\x02\x20\x01(\x0b2\x18.dto.GameMessage.PingMsgH\0\
    R\x04ping\x121\n\x05steer\x18\x03\x20\x01(\x0b2\x19.dto.GameMessage.Stee\
    rMsgH\0R\x05steer\x12+\n\x03ack\x18\x04\x20\x01(\x0b2\x17.dto.GameMessag\
    e.AckMsgH\0R\x03ack\x121\n\x05state\x18\x05\x20\x01(\x0b2\x19.dto.GameMe\
    ssage.StateMsgH\0R\x05state\x12F\n\x0cannouncement\x18\x06\x20\x01(\x0b2\
    \x20.dto.GameMessage.AnnouncementMsgH\0R\x0cannouncement\x12.\n\x04join\
    \x18\x07\x20\x01(\x0b2\x18.dto.GameMessage.JoinMsgH\0R\x04join\x121\n\
    \x05error\x18\x08\x20\x01(\x0b2\x19.dto.GameMessage.ErrorMsgH\0R\x05erro\
    r\x12A\n\x0brole_change\x18\t\x20\x01(\x0b2\x1e.dto.GameMessage.RoleChan\
    geMsgH\0R\nroleChange\x12:\n\x08discover\x18\x0c\x20\x01(\x0b2\x1c.dto.G\
    ameMessage.DiscoverMsgH\0R\x08discover\x1a\t\n\x07PingMsg\x1a8\n\x08Stee\
    rMsg\x12,\n\tdirection\x18\x01\x20\x02(\x0e2\x0e.dto.DirectionR\tdirecti\
    on\x1a\x08\n\x06AckMsg\x1a0\n\x08StateMsg\x12$\n\x05state\x18\x01\x20\
    \x02(\x0b2\x0e.dto.GameStateR\x05state\x1a>\n\x0fAnnouncementMsg\x12+\n\
    \x05games\x18\x01\x20\x03(\x0b2\x15.dto.GameAnnouncementR\x05games\x1a\r\
    \n\x0bDiscoverMsg\x1a\xb6\x01\n\x07JoinMsg\x127\n\x0bplayer_type\x18\x01\
    \x20\x01(\x0e2\x0f.dto.PlayerType:\x05HUMANR\nplayerType\x12\x1f\n\x0bpl\
    ayer_name\x18\x03\x20\x02(\tR\nplayerName\x12\x1b\n\tgame_name\x18\x04\
    \x20\x02(\tR\x08gameName\x124\n\x0erequested_role\x18\x05\x20\x02(\x0e2\
    \r.dto.NodeRoleR\rrequestedRole\x1a/\n\x08ErrorMsg\x12#\n\rerror_message\
    \x18\x01\x20\x02(\tR\x0cerrorMessage\x1as\n\rRoleChangeMsg\x12.\n\x0bsen\
    der_role\x18\x01\x20\x01(\x0e2\r.dto.NodeRoleR\nsenderRole\x122\n\rrecei\
    ver_role\x18\x02\x20\x01(\x0e2\r.dto.NodeRoleR\x0creceiverRoleB\x06\n\
    \x04Type*:\n\x08NodeRole\x12\n\n\x06NORMAL\x10\0\x12\n\n\x06MASTER\x10\
    \x01\x12\n\n\x06DEPUTY\x10\x02\x12\n\n\x06VIEWER\x10\x03*\"\n\nPlayerTyp\
    e\x12\t\n\x05HUMAN\x10\0\x12\t\n\x05ROBOT\x10\x01*2\n\tDirection\x12\x06\
    \n\x02UP\x10\x01\x12\x08\n\x04DOWN\x10\x02\x12\x08\n\x04LEFT\x10\x03\x12\
    \t\n\x05RIGHT\x10\x04J\xeb^\n\x07\x12\x05\0\0\x91\x01\x01\n\x08\n\x01\
    \x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x0c\nk\n\x02\x05\0\
    \x12\x04\x04\0\t\x01\x1a_\x20\xd0\xa0\xd0\xbe\xd0\xbb\xd1\x8c\x20\xd1\
    \x83\xd0\xb7\xd0\xbb\xd0\xb0\x20\xd0\xb2\x20\xd1\x82\xd0\xbe\xd0\xbf\xd0\
    \xbe\xd0\xbb\xd0\xbe\xd0\xb3\xd0\xb8\xd0\xb8\x20\xd1\x81\xd0\xb2\xd1\x8f\
    \xd0\xb7\xd0\xb5\xd0\xb9\x20\xd1\x83\xd0\xb7\xd0\xbb\xd0\xbe\xd0\xb2\x20\
    \xd0\xb2\x20\xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\xd1\
    \x85\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b\r\n\n\n\n\x03\x05\0\x01\x12\x03\
    \x04\x05\r\nV\n\x04\x05\0\x02\0\x12\x03\x05\x04\x0f\"I\x20\xd0\x9e\xd0\
    \xb1\xd1\x8b\xd1\x87\xd0\xbd\xd1\x8b\xd0\xb9\x20\xd1\x83\xd0\xb7\xd0\xb5\
    \xd0\xbb,\x20\xd0\xbb\xd0\xb8\xd1\x81\xd1\x82\x20\xd0\xb2\x20\xd1\x82\
    \xd0\xbe\xd0\xbf\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb3\xd0\xb8\xd0\xb8\x20\"\
    \xd0\xb7\xd0\xb2\xd0\xb5\xd0\xb7\xd0\xb4\xd0\xb0\"\r\n\n\x0c\n\x05\x05\0\
    \x02\0\x01\x12\x03\x05\x04\n\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x05\r\
    \x0e\nX\n\x04\x05\0\x02\x01\x12\x03\x06\x04\x0f\"K\x20\xd0\x93\xd0\xbb\
    \xd0\xb0\xd0\xb2\xd0\xbd\xd1\x8b\xd0\xb9\x20\xd1\x83\xd0\xb7\xd0\xb5\xd0\
    \xbb,\x20\xd1\x86\xd0\xb5\xd0\xbd\xd1\x82\xd1\x80\x20\xd0\xb2\x20\xd1\
    \x82\xd0\xbe\xd0\xbf\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb3\xd0\xb8\xd0\xb8\x20\
    \"\xd0\xb7\xd0\xb2\xd0\xb5\xd0\xb7\xd0\xb4\xd0\xb0\"\r\n\n\x0c\n\x05\x05\
    \0\x02\x01\x01\x12\x03\x06\x04\n\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\
    \x06\r\x0e\n@\n\x04\x05\0\x02\x02\x12\x03\x07\x04\x0f\"3\x20\xd0\x97\xd0\
    \xb0\xd0\xbc\xd0\xb5\xd1\x81\xd1\x82\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\
    \x8c\x20\xd0\xb3\xd0\xbb\xd0\xb0\xd0\xb2\xd0\xbd\xd0\xbe\xd0\xb3\xd0\xbe\
    \x20\xd1\x83\xd0\xb7\xd0\xbb\xd0\xb0\r\n\n\x0c\n\x05\x05\0\x02\x02\x01\
    \x12\x03\x07\x04\n\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x07\r\x0e\n\xb9\
    \x01\n\x04\x05\0\x02\x03\x12\x03\x08\x04\x0f\"\xab\x01\x20\xd0\x9d\xd0\
    \xb0\xd0\xb1\xd0\xbb\xd1\x8e\xd0\xb4\xd0\xb0\xd1\x82\xd0\xb5\xd0\xbb\xd1\
    \x8c,\x20\xd0\xbf\xd0\xbe\xd1\x85\xd0\xbe\xd0\xb6\x20\xd0\xbd\xd0\xb0\
    \x20NORMAL,\x20\xd0\xbd\xd0\xbe\x20\xd0\xbd\xd0\xb5\x20\xd0\xb8\xd0\xbc\
    \xd0\xb5\xd0\xb5\xd1\x82\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8\x20\xd0\xb2\
    \x20\xd1\x81\xd1\x82\xd0\xb0\xd1\x82\xd1\x83\xd1\x81\xd0\xb5\x20ALIVE,\
    \x20\xd1\x82\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xba\xd0\xbe\x20\xd0\xbf\xd0\xbe\
    \xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\xd0\xb5\xd1\x82\x20\xd0\xbe\xd0\xb1\xd0\
    \xbd\xd0\xbe\xd0\xb2\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\x20\xd1\x81\
    \xd1\x82\xd0\xb0\xd1\x82\xd1\x83\xd1\x81\xd0\xb0\r\n\n\x0c\n\x05\x05\0\
    \x02\x03\x01\x12\x03\x08\x04\n\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x08\
    \r\x0e\n\"\n\x02\x05\x01\x12\x04\x0c\0\x0f\x01\x1a\x16\x20\xd0\xa2\xd0\
    \xb8\xd0\xbf\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\r\n\n\n\
    \n\x03\x05\x01\x01\x12\x03\x0c\x05\x0f\n3\n\x04\x05\x01\x02\0\x12\x03\r\
    \x04\x0e\"&\x20\xd0\x96\xd0\xb8\xd0\xb2\xd0\xbe\xd0\xb9\x20\xd0\xbf\xd0\
    \xbe\xd0\xbb\xd1\x8c\xd0\xb7\xd0\xbe\xd0\xb2\xd0\xb0\xd1\x82\xd0\xb5\xd0\
    \xbb\xd1\x8c\r\n\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\r\x04\t\n\x0c\n\
    \x05\x05\x01\x02\0\x02\x12\x03\r\x0c\r\n\xe9\x01\n\x04\x05\x01\x02\x01\
    \x12\x03\x0e\x04\x0e\"\xdb\x01\x20\xd0\xa0\xd0\xbe\xd0\xb1\xd0\xbe\xd1\
    \x82,\x20\xd1\x83\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\xd1\x8f\xd0\
    \xb5\xd1\x82\x20\xd1\x81\xd0\xb2\xd0\xbe\xd0\xb5\xd0\xb9\x20\xd0\xb7\xd0\
    \xbc\xd0\xb5\xd1\x91\xd0\xb9\x20\xd1\x81\x20\xd0\xbf\xd0\xbe\xd0\xbc\xd0\
    \xbe\xd1\x89\xd1\x8c\xd1\x8e\x20\xd0\xb0\xd0\xbb\xd0\xb3\xd0\xbe\xd1\x80\
    \xd0\xb8\xd1\x82\xd0\xbc\xd0\xb0\x20(\xd1\x8d\xd1\x82\xd0\xbe\x20\xd0\
    \xbd\xd0\xb5\x20\xd0\xbd\xd1\x83\xd0\xb6\xd0\xbd\xd0\xbe\x20\xd1\x80\xd0\
    \xb5\xd0\xb0\xd0\xbb\xd0\xb8\xd0\xb7\xd0\xbe\xd0\xb2\xd1\x8b\xd0\xb2\xd0\
    \xb0\xd1\x82\xd1\x8c,\x20\xd0\xbd\xd0\xbe\x20\xd0\xbf\xd1\x80\xd0\xb5\
    \xd0\xb4\xd1\x83\xd1\x81\xd0\xbc\xd0\xbe\xd1\x82\xd1\x80\xd0\xb5\xd0\xbd\
    \xd0\xbe\x20\xd0\xb2\x20\xd0\xbf\xd1\x80\xd0\xbe\xd1\x82\xd0\xbe\xd0\xba\
    \xd0\xbe\xd0\xbb\xd0\xb5\x20\xd0\xbd\xd0\xb0\x20\xd0\xb1\xd1\x83\xd0\xb4\
    \xd1\x83\xd1\x89\xd0\xb5\xd0\xb5)\r\n\n\x0c\n\x05\x05\x01\x02\x01\x01\
    \x12\x03\x0e\x04\t\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x0e\x0c\r\n\
    \x19\n\x02\x04\0\x12\x04\x12\0\x1a\x01\x1a\r\x20\xd0\x98\xd0\xb3\xd1\x80\
    \xd0\xbe\xd0\xba\r\n\n\n\n\x03\x04\0\x01\x12\x03\x12\x08\x12\n[\n\x04\
    \x04\0\x02\0\x12\x03\x13\x04\x1d\"N\x20\xd0\x98\xd0\xbc\xd1\x8f\x20\xd0\
    \xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\x20(\xd0\xb4\xd0\xbb\xd1\
    \x8f\x20\xd0\xbe\xd1\x82\xd0\xbe\xd0\xb1\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\
    \xd0\xbd\xd0\xb8\xd1\x8f\x20\xd0\xb2\x20\xd0\xb8\xd0\xbd\xd1\x82\xd0\xb5\
    \xd1\x80\xd1\x84\xd0\xb5\xd0\xb9\xd1\x81\xd0\xb5)\r\n\n\x0c\n\x05\x04\0\
    \x02\0\x04\x12\x03\x13\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x13\r\
    \x13\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x13\x14\x18\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03\x13\x1b\x1c\ni\n\x04\x04\0\x02\x01\x12\x03\x14\x04\
    \x1a\"\\\x20\xd0\xa3\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\xd1\x8c\xd0\
    \xbd\xd1\x8b\xd0\xb9\x20\xd0\xb8\xd0\xb4\xd0\xb5\xd0\xbd\xd1\x82\xd0\xb8\
    \xd1\x84\xd0\xb8\xd0\xba\xd0\xb0\xd1\x82\xd0\xbe\xd1\x80\x20\xd0\xb8\xd0\
    \xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\x20\xd0\xb2\x20\xd0\xbf\xd1\x80\xd0\
    \xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x85\x20\xd0\xb8\xd0\xb3\xd1\x80\
    \xd1\x8b\r\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x14\x04\x0c\n\x0c\n\
    \x05\x04\0\x02\x01\x05\x12\x03\x14\r\x12\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03\x14\x13\x15\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x14\x18\x19\n\
    \xb5\x01\n\x04\x04\0\x02\x02\x12\x03\x15\x04#\"\xa7\x01\x20IPv4\x20\xd0\
    \xb8\xd0\xbb\xd0\xb8\x20IPv6\x20\xd0\xb0\xd0\xb4\xd1\x80\xd0\xb5\xd1\x81\
    \x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\x20\xd0\xb2\x20\xd0\
    \xb2\xd0\xb8\xd0\xb4\xd0\xb5\x20\xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\
    \xd0\xb8.\x20\xd0\x9e\xd1\x82\xd1\x81\xd1\x83\xd1\x82\xd1\x81\xd1\x82\
    \xd0\xb2\xd1\x83\xd0\xb5\xd1\x82\x20\xd0\xb2\x20\xd0\xbe\xd0\xbf\xd0\xb8\
    \xd1\x81\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\
    \xbe\xd0\xba\xd0\xb0-\xd0\xbe\xd1\x82\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\
    \xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8f\x20\xd1\x81\xd0\xbe\xd0\xbe\xd0\
    \xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\r\n\n\x0c\n\x05\x04\0\x02\
    \x02\x04\x12\x03\x15\x04\x0c\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x15\r\
    \x13\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x15\x14\x1e\n\x0c\n\x05\x04\0\
    \x02\x02\x03\x12\x03\x15!\"\n\x9a\x01\n\x04\x04\0\x02\x03\x12\x03\x16\
    \x04\x1c\"\x8c\x01\x20\xd0\x9f\xd0\xbe\xd1\x80\xd1\x82\x20UDP-\xd1\x81\
    \xd0\xbe\xd0\xba\xd0\xb5\xd1\x82\xd0\xb0\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\
    \xbe\xd0\xba\xd0\xb0.\x20\xd0\x9e\xd1\x82\xd1\x81\xd1\x83\xd1\x82\xd1\
    \x81\xd1\x82\xd0\xb2\xd1\x83\xd0\xb5\xd1\x82\x20\xd0\xb2\x20\xd0\xbe\xd0\
    \xbf\xd0\xb8\xd1\x81\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xb8\xd0\xb3\
    \xd1\x80\xd0\xbe\xd0\xba\xd0\xb0-\xd0\xbe\xd1\x82\xd0\xbf\xd1\x80\xd0\
    \xb0\xd0\xb2\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8f\x20\xd1\x81\xd0\xbe\
    \xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\r\n\n\x0c\n\x05\
    \x04\0\x02\x03\x04\x12\x03\x16\x04\x0c\n\x0c\n\x05\x04\0\x02\x03\x05\x12\
    \x03\x16\r\x12\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x16\x13\x17\n\x0c\n\
    \x05\x04\0\x02\x03\x03\x12\x03\x16\x1a\x1b\n7\n\x04\x04\0\x02\x04\x12\
    \x03\x17\x04\x1f\"*\x20\xd0\xa0\xd0\xbe\xd0\xbb\xd1\x8c\x20\xd1\x83\xd0\
    \xb7\xd0\xbb\xd0\xb0\x20\xd0\xb2\x20\xd1\x82\xd0\xbe\xd0\xbf\xd0\xbe\xd0\
    \xbb\xd0\xbe\xd0\xb3\xd0\xb8\xd0\xb8\r\n\n\x0c\n\x05\x04\0\x02\x04\x04\
    \x12\x03\x17\x04\x0c\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03\x17\r\x15\n\
    \x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x17\x16\x1a\n\x0c\n\x05\x04\0\x02\
    \x04\x03\x12\x03\x17\x1d\x1e\n#\n\x04\x04\0\x02\x05\x12\x03\x18\x043\"\
    \x16\x20\xd0\xa2\xd0\xb8\xd0\xbf\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\
    \xba\xd0\xb0\r\n\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\x18\x04\x0c\n\x0c\
    \n\x05\x04\0\x02\x05\x06\x12\x03\x18\r\x17\n\x0c\n\x05\x04\0\x02\x05\x01\
    \x12\x03\x18\x18\x1c\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x18\x1f\x20\n\
    \x0c\n\x05\x04\0\x02\x05\x08\x12\x03\x18!2\n\x0c\n\x05\x04\0\x02\x05\x07\
    \x12\x03\x18,1\nM\n\x04\x04\0\x02\x06\x12\x03\x19\x04\x1d\"@\x20\xd0\xa7\
    \xd0\xb8\xd1\x81\xd0\xbb\xd0\xbe\x20\xd0\xbe\xd1\x87\xd0\xba\xd0\xbe\xd0\
    \xb2,\x20\xd0\xba\xd0\xbe\xd1\x82\xd0\xbe\xd1\x80\xd1\x8b\xd0\xb5\x20\
    \xd0\xbd\xd0\xb0\xd0\xb1\xd1\x80\xd0\xb0\xd0\xbb\x20\xd0\xb8\xd0\xb3\xd1\
    \x80\xd0\xbe\xd0\xba\r\n\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03\x19\x04\
    \x0c\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x19\r\x12\n\x0c\n\x05\x04\0\
    \x02\x06\x01\x12\x03\x19\x13\x18\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\
    \x19\x1b\x1c\nx\n\x02\x04\x01\x12\x04\x1d\0\"\x01\x1al\x20\xd0\x9f\xd0\
    \xb0\xd1\x80\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x82\xd1\x80\xd1\x8b\x20\xd0\xb8\
    \xd0\xb4\xd1\x83\xd1\x89\xd0\xb5\xd0\xb9\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\
    \x8b\x20(\xd0\xbd\xd0\xb5\x20\xd0\xb4\xd0\xbe\xd0\xbb\xd0\xb6\xd0\xbd\
    \xd1\x8b\x20\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x8f\xd1\x82\xd1\x8c\xd1\x81\xd1\
    \x8f\x20\xd0\xb2\x20\xd0\xbf\xd1\x80\xd0\xbe\xd1\x86\xd0\xb5\xd1\x81\xd1\
    \x81\xd0\xb5\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b)\x20\n\n\n\x03\x04\x01\
    \x01\x12\x03\x1d\x08\x12\nJ\n\x04\x04\x01\x02\0\x12\x03\x1e\x04,\"=\x20\
    \xd0\xa8\xd0\xb8\xd1\x80\xd0\xb8\xd0\xbd\xd0\xb0\x20\xd0\xbf\xd0\xbe\xd0\
    \xbb\xd1\x8f\x20\xd0\xb2\x20\xd0\xba\xd0\xbb\xd0\xb5\xd1\x82\xd0\xba\xd0\
    \xb0\xd1\x85\x20(\xd0\xbe\xd1\x82\x2010\x20\xd0\xb4\xd0\xbe\x20100)\r\n\
    \n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x1e\x04\x0c\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03\x1e\r\x12\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1e\
    \x13\x18\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1e\x1b\x1c\n\x0c\n\x05\
    \x04\x01\x02\0\x08\x12\x03\x1e\x1d+\n\x0c\n\x05\x04\x01\x02\0\x07\x12\
    \x03\x1e(*\nJ\n\x04\x04\x01\x02\x01\x12\x03\x1f\x04-\"=\x20\xd0\x92\xd1\
    \x8b\xd1\x81\xd0\xbe\xd1\x82\xd0\xb0\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f\
    \x20\xd0\xb2\x20\xd0\xba\xd0\xbb\xd0\xb5\xd1\x82\xd0\xba\xd0\xb0\xd1\x85\
    \x20(\xd0\xbe\xd1\x82\x2010\x20\xd0\xb4\xd0\xbe\x20100)\r\n\n\x0c\n\x05\
    \x04\x01\x02\x01\x04\x12\x03\x1f\x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\x05\
    \x12\x03\x1f\r\x12\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x1f\x13\x19\n\
    \x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1f\x1c\x1d\n\x0c\n\x05\x04\x01\
    \x02\x01\x08\x12\x03\x1f\x1e,\n\x0c\n\x05\x04\x01\x02\x01\x07\x12\x03\
    \x1f)+\n\x84\x01\n\x04\x04\x01\x02\x02\x12\x03\x20\x041\"w\x20\xd0\x9a\
    \xd0\xbe\xd0\xbb\xd0\xb8\xd1\x87\xd0\xb5\xd1\x81\xd1\x82\xd0\xb2\xd0\xbe\
    \x20\xd0\xba\xd0\xbb\xd0\xb5\xd1\x82\xd0\xbe\xd0\xba\x20\xd1\x81\x20\xd0\
    \xb5\xd0\xb4\xd0\xbe\xd0\xb9,\x20\xd0\xbd\xd0\xb5\xd0\xb7\xd0\xb0\xd0\
    \xb2\xd0\xb8\xd1\x81\xd0\xb8\xd0\xbc\xd0\xbe\x20\xd0\xbe\xd1\x82\x20\xd1\
    \x87\xd0\xb8\xd1\x81\xd0\xbb\xd0\xb0\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\
    \xd0\xba\xd0\xbe\xd0\xb2\x20(\xd0\xbe\xd1\x82\x200\x20\xd0\xb4\xd0\xbe\
    \x20100)\r\n\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\x20\x04\x0c\n\x0c\n\
    \x05\x04\x01\x02\x02\x05\x12\x03\x20\r\x12\n\x0c\n\x05\x04\x01\x02\x02\
    \x01\x12\x03\x20\x13\x1e\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x20!\"\
    \n\x0c\n\x05\x04\x01\x02\x02\x08\x12\x03\x20#0\n\x0c\n\x05\x04\x01\x02\
    \x02\x07\x12\x03\x20./\n\x9b\x01\n\x04\x04\x01\x02\x03\x12\x03!\x047\"\
    \x8d\x01\x20\xd0\x97\xd0\xb0\xd0\xb4\xd0\xb5\xd1\x80\xd0\xb6\xd0\xba\xd0\
    \xb0\x20\xd0\xbc\xd0\xb5\xd0\xb6\xd0\xb4\xd1\x83\x20\xd1\x85\xd0\xbe\xd0\
    \xb4\xd0\xb0\xd0\xbc\xd0\xb8\x20(\xd1\x81\xd0\xbc\xd0\xb5\xd0\xbd\xd0\
    \xbe\xd0\xb9\x20\xd1\x81\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd1\x8f\xd0\xbd\
    \xd0\xb8\xd0\xb9)\x20\xd0\xb2\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xb5,\x20\
    \xd0\xb2\x20\xd0\xbc\xd0\xb8\xd0\xbb\xd0\xbb\xd0\xb8\xd1\x81\xd0\xb5\xd0\
    \xba\xd1\x83\xd0\xbd\xd0\xb4\xd0\xb0\xd1\x85\x20(\xd0\xbe\xd1\x82\x20100\
    \x20\xd0\xb4\xd0\xbe\x203000)\r\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\
    \x03!\x04\x0c\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03!\r\x12\n\x0c\n\x05\
    \x04\x01\x02\x03\x01\x12\x03!\x13!\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\
    \x03!$%\n\x0c\n\x05\x04\x01\x02\x03\x08\x12\x03!&6\n\x0c\n\x05\x04\x01\
    \x02\x03\x07\x12\x03!15\n8\n\x02\x04\x02\x12\x04%\0'\x01\x1a,\x20\xd0\
    \x98\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb8\x20\xd0\xba\xd0\xbe\xd0\xbd\
    \xd0\xba\xd1\x80\xd0\xb5\xd1\x82\xd0\xbd\xd0\xbe\xd0\xb9\x20\xd0\xb8\xd0\
    \xb3\xd1\x80\xd1\x8b\x20\n\n\n\x03\x04\x02\x01\x12\x03%\x08\x13\n4\n\x04\
    \x04\x02\x02\0\x12\x03&\x04$\"'\x20\xd0\xa1\xd0\xbf\xd0\xb8\xd1\x81\xd0\
    \xbe\xd0\xba\x20\xd0\xb2\xd1\x81\xd0\xb5\xd1\x85\x20\xd0\xb8\xd0\xb3\xd1\
    \x80\xd0\xbe\xd0\xba\xd0\xbe\xd0\xb2\r\n\n\x0c\n\x05\x04\x02\x02\0\x04\
    \x12\x03&\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03&\r\x17\n\x0c\n\
    \x05\x04\x02\x02\0\x01\x12\x03&\x18\x1f\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03&\"#\n\n\n\x02\x05\x02\x12\x04)\0.\x01\n\n\n\x03\x05\x02\x01\x12\
    \x03)\x05\x0e\nZ\n\x04\x05\x02\x02\0\x12\x03*\x04\x0b\"M\x20\xd0\x92\xd0\
    \xb2\xd0\xb5\xd1\x80\xd1\x85\x20(\xd0\xb2\x20\xd0\xbe\xd1\x82\xd1\x80\
    \xd0\xb8\xd1\x86\xd0\xb0\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\
    \xd0\xbc\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\xd0\
    \xb5\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xbe\xd1\x81\xd0\xb8\x20y)\r\n\n\x0c\
    \n\x05\x05\x02\x02\0\x01\x12\x03*\x04\x06\n\x0c\n\x05\x05\x02\x02\0\x02\
    \x12\x03*\t\n\nX\n\x04\x05\x02\x02\x01\x12\x03+\x04\r\"K\x20\xd0\x92\xd0\
    \xbd\xd0\xb8\xd0\xb7\x20(\xd0\xb2\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd0\xbe\
    \xd0\xb6\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\xd0\xbc\
    \x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\xd0\xb5\xd0\
    \xbd\xd0\xb8\xd0\xb8\x20\xd0\xbe\xd1\x81\xd0\xb8\x20y)\r\n\n\x0c\n\x05\
    \x05\x02\x02\x01\x01\x12\x03+\x04\x08\n\x0c\n\x05\x05\x02\x02\x01\x02\
    \x12\x03+\x0b\x0c\nZ\n\x04\x05\x02\x02\x02\x12\x03,\x04\r\"M\x20\xd0\x92\
    \xd0\xbb\xd0\xb5\xd0\xb2\xd0\xbe\x20(\xd0\xb2\x20\xd0\xbe\xd1\x82\xd1\
    \x80\xd0\xb8\xd1\x86\xd0\xb0\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\
    \xbe\xd0\xbc\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\
    \xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xbe\xd1\x81\xd0\xb8\x20x)\r\n\n\
    \x0c\n\x05\x05\x02\x02\x02\x01\x12\x03,\x04\x08\n\x0c\n\x05\x05\x02\x02\
    \x02\x02\x12\x03,\x0b\x0c\n\\\n\x04\x05\x02\x02\x03\x12\x03-\x04\x0e\"O\
    \x20\xd0\x92\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbe\x20(\xd0\xb2\x20\
    \xd0\xbf\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb6\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\
    \xd1\x8c\xd0\xbd\xd0\xbe\xd0\xbc\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\
    \xb0\xd0\xb2\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xbe\xd1\x81\
    \xd0\xb8\x20x)\r\n\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03-\x04\t\n\x0c\
    \n\x05\x05\x02\x02\x03\x02\x12\x03-\x0c\r\nI\n\x02\x04\x03\x12\x041\0L\
    \x01\x1a=\x20\xd0\xa2\xd0\xb5\xd0\xba\xd1\x83\xd1\x89\xd0\xb5\xd0\xb5\
    \x20\xd1\x81\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd1\x8f\xd0\xbd\xd0\xb8\xd0\
    \xb5\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xb2\xd0\xbe\xd0\xb3\xd0\xbe\
    \x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f\x20\n\n\n\x03\x04\x03\x01\x12\x031\
    \x08\x11\n\xcf\x02\n\x04\x04\x03\x03\0\x12\x045\x048\x05\x1a\xc0\x02\x20\
    \xd0\x9a\xd0\xbe\xd0\xbe\xd1\x80\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb0\xd1\x82\
    \xd1\x8b\x20\xd0\xb2\x20\xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\
    \xd0\xb0\xd1\x85\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xb2\xd0\xbe\xd0\
    \xb3\xd0\xbe\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f,\x20\xd0\xbb\xd0\xb8\
    \xd0\xb1\xd0\xbe\x20\xd0\xbe\xd1\x82\xd0\xbd\xd0\xbe\xd1\x81\xd0\xb8\xd1\
    \x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\xd0\xb5\x20\xd1\x81\xd0\xbc\
    \xd0\xb5\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\xd0\xba\xd0\xbe\xd0\
    \xbe\xd1\x80\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb0\xd1\x82.\r\n\x20\xd0\x9b\
    \xd0\xb5\xd0\xb2\xd0\xb0\xd1\x8f\x20\xd0\xb2\xd0\xb5\xd1\x80\xd1\x85\xd0\
    \xbd\xd1\x8f\xd1\x8f\x20\xd0\xba\xd0\xbb\xd0\xb5\xd1\x82\xd0\xba\xd0\xb0\
    \x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f\x20\xd0\xb8\xd0\xbc\xd0\xb5\xd0\xb5\
    \xd1\x82\x20\xd0\xba\xd0\xbe\xd0\xbe\xd1\x80\xd0\xb4\xd0\xb8\xd0\xbd\xd0\
    \xb0\xd1\x82\xd1\x8b\x20(x=0,\x20y=0).\r\n\x20\xd0\x9d\xd0\xb0\xd0\xbf\
    \xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\xd1\
    \x81\xd0\xbc\xd0\xb5\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\x20\xd0\xb7\
    \xd0\xb0\xd0\xb4\xd0\xb0\xd1\x91\xd1\x82\xd1\x81\xd1\x8f\x20\xd0\xb7\xd0\
    \xbd\xd0\xb0\xd0\xba\xd0\xbe\xd0\xbc\x20\xd1\x87\xd0\xb8\xd1\x81\xd0\xb5\
    \xd0\xbb.\x20\n\x0c\n\x05\x04\x03\x03\0\x01\x12\x035\x0c\x11\n|\n\x06\
    \x04\x03\x03\0\x02\0\x12\x036\x08,\"m\x20\xd0\x9f\xd0\xbe\x20\xd0\xb3\
    \xd0\xbe\xd1\x80\xd0\xb8\xd0\xb7\xd0\xbe\xd0\xbd\xd1\x82\xd0\xb0\xd0\xbb\
    \xd1\x8c\xd0\xbd\xd0\xbe\xd0\xb9\x20\xd0\xbe\xd1\x81\xd0\xb8,\x20\xd0\
    \xbf\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb6\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\
    \x8c\xd0\xbd\xd0\xbe\xd0\xb5\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\
    \xd0\xb2\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20-\x20\xd0\xb2\xd0\
    \xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbe\r\n\n\x0e\n\x07\x04\x03\x03\0\x02\0\
    \x04\x12\x036\x08\x10\n\x0e\n\x07\x04\x03\x03\0\x02\0\x05\x12\x036\x11\
    \x17\n\x0e\n\x07\x04\x03\x03\0\x02\0\x01\x12\x036\x18\x19\n\x0e\n\x07\
    \x04\x03\x03\0\x02\0\x03\x12\x036\x1c\x1d\n\x0e\n\x07\x04\x03\x03\0\x02\
    \0\x08\x12\x036\x1e+\n\x0e\n\x07\x04\x03\x03\0\x02\0\x07\x12\x036)*\nt\n\
    \x06\x04\x03\x03\0\x02\x01\x12\x037\x08,\"e\x20\xd0\x9f\xd0\xbe\x20\xd0\
    \xb2\xd0\xb5\xd1\x80\xd1\x82\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\xd1\x8c\xd0\
    \xbd\xd0\xbe\xd0\xb9\x20\xd0\xbe\xd1\x81\xd0\xb8,\x20\xd0\xbf\xd0\xbe\
    \xd0\xbb\xd0\xbe\xd0\xb6\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\
    \xd0\xbe\xd0\xb5\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\
    \xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20-\x20\xd0\xb2\xd0\xbd\xd0\xb8\
    \xd0\xb7\r\n\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x04\x12\x037\x08\x10\n\
    \x0e\n\x07\x04\x03\x03\0\x02\x01\x05\x12\x037\x11\x17\n\x0e\n\x07\x04\
    \x03\x03\0\x02\x01\x01\x12\x037\x18\x19\n\x0e\n\x07\x04\x03\x03\0\x02\
    \x01\x03\x12\x037\x1c\x1d\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x08\x12\x037\
    \x1e+\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x07\x12\x037)*\n\x19\n\x04\x04\
    \x03\x03\x01\x12\x04:\x04G\x05\x1a\x0b\x20\xd0\x97\xd0\xbc\xd0\xb5\xd1\
    \x8f\r\n\n\x0c\n\x05\x04\x03\x03\x01\x01\x12\x03:\x0c\x11\n4\n\x06\x04\
    \x03\x03\x01\x04\0\x12\x04<\x08?\t\x1a$\x20\xd0\xa1\xd1\x82\xd0\xb0\xd1\
    \x82\xd1\x83\xd1\x81\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8\x20\xd0\xb2\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd0\xb5\r\n\n\x0e\n\x07\x04\x03\x03\x01\x04\0\
    \x01\x12\x03<\r\x17\nB\n\x08\x04\x03\x03\x01\x04\0\x02\0\x12\x03=\x0c\
    \x16\"1\x20\xd0\x97\xd0\xbc\xd0\xb5\xd1\x8f\x20\xd1\x83\xd0\xbf\xd1\x80\
    \xd0\xb0\xd0\xb2\xd0\xbb\xd1\x8f\xd0\xb5\xd1\x82\xd1\x81\xd1\x8f\x20\xd0\
    \xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xbe\xd0\xbc\r\n\n\x10\n\t\x04\
    \x03\x03\x01\x04\0\x02\0\x01\x12\x03=\x0c\x11\n\x10\n\t\x04\x03\x03\x01\
    \x04\0\x02\0\x02\x12\x03=\x14\x15\n\xbb\x01\n\x08\x04\x03\x03\x01\x04\0\
    \x02\x01\x12\x03>\x0c\x17\"\xa9\x01\x20\xd0\x97\xd0\xbc\xd0\xb5\xd1\x8f\
    \x20\xd0\xbf\xd1\x80\xd0\xb8\xd0\xbd\xd0\xb0\xd0\xb4\xd0\xbb\xd0\xb5\xd0\
    \xb6\xd0\xb0\xd0\xbb\xd0\xb0\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\
    \xd1\x83,\x20\xd0\xba\xd0\xbe\xd1\x82\xd0\xbe\xd1\x80\xd1\x8b\xd0\xb9\
    \x20\xd0\xb2\xd1\x8b\xd1\x88\xd0\xb5\xd0\xbb\x20\xd0\xb8\xd0\xb7\x20\xd0\
    \xb8\xd0\xb3\xd1\x80\xd1\x8b,\x20\xd0\xbe\xd0\xbd\xd0\xb0\x20\xd0\xbf\
    \xd1\x80\xd0\xbe\xd0\xb4\xd0\xbe\xd0\xbb\xd0\xb6\xd0\xb0\xd0\xb5\xd1\x82\
    \x20\xd0\xb4\xd0\xb2\xd0\xb8\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\
    \xd0\xba\xd1\x83\xd0\xb4\xd0\xb0\x20\xd0\xb3\xd0\xbb\xd0\xb0\xd0\xb7\xd0\
    \xb0\x20\xd0\xb3\xd0\xbb\xd1\x8f\xd0\xb4\xd1\x8f\xd1\x82\r\n\n\x10\n\t\
    \x04\x03\x03\x01\x04\0\x02\x01\x01\x12\x03>\x0c\x12\n\x10\n\t\x04\x03\
    \x03\x01\x04\0\x02\x01\x02\x12\x03>\x15\x16\nj\n\x06\x04\x03\x03\x01\x02\
    \0\x12\x03@\x08%\"[\x20\xd0\x98\xd0\xb4\xd0\xb5\xd0\xbd\xd1\x82\xd0\xb8\
    \xd1\x84\xd0\xb8\xd0\xba\xd0\xb0\xd1\x82\xd0\xbe\xd1\x80\x20\xd0\xb8\xd0\
    \xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0-\xd0\xb2\xd0\xbb\xd0\xb0\xd0\xb4\
    \xd0\xb5\xd0\xbb\xd1\x8c\xd1\x86\xd0\xb0\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\
    \xb8,\x20\xd1\x81\xd0\xbc.\x20GamePlayer.id\r\n\n\x0e\n\x07\x04\x03\x03\
    \x01\x02\0\x04\x12\x03@\x08\x10\n\x0e\n\x07\x04\x03\x03\x01\x02\0\x05\
    \x12\x03@\x11\x16\n\x0e\n\x07\x04\x03\x03\x01\x02\0\x01\x12\x03@\x17\x20\
    \n\x0e\n\x07\x04\x03\x03\x01\x02\0\x03\x12\x03@#$\n\xe3\x03\n\x06\x04\
    \x03\x03\x01\x02\x01\x12\x03D\x08\"\x1a\xd3\x03\x20\xd0\xa1\xd0\xbf\xd0\
    \xb8\xd1\x81\xd0\xbe\xd0\xba\x20\"\xd0\xba\xd0\xbb\xd1\x8e\xd1\x87\xd0\
    \xb5\xd0\xb2\xd1\x8b\xd1\x85\"\x20\xd1\x82\xd0\xbe\xd1\x87\xd0\xb5\xd0\
    \xba\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8.\x20\xd0\x9f\xd0\xb5\xd1\x80\
    \xd0\xb2\xd0\xb0\xd1\x8f\x20\xd1\x82\xd0\xbe\xd1\x87\xd0\xba\xd0\xb0\x20\
    \xd1\x85\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb8\xd1\x82\x20\xd0\xba\xd0\xbe\xd0\
    \xbe\xd1\x80\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb0\xd1\x82\xd1\x8b\x20\xd0\xb3\
    \xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb2\xd1\x8b\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\
    \xb8.\r\n\x20\xd0\x9a\xd0\xb0\xd0\xb6\xd0\xb4\xd0\xb0\xd1\x8f\x20\xd1\
    \x81\xd0\xbb\xd0\xb5\xd0\xb4\xd1\x83\xd1\x8e\xd1\x89\xd0\xb0\xd1\x8f\x20\
    -\x20\xd1\x81\xd0\xbc\xd0\xb5\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\
    \x20\xd1\x81\xd0\xbb\xd0\xb5\xd0\xb4\xd1\x83\xd1\x8e\xd1\x89\xd0\xb5\xd0\
    \xb9\x20\"\xd0\xba\xd0\xbb\xd1\x8e\xd1\x87\xd0\xb5\xd0\xb2\xd0\xbe\xd0\
    \xb9\"\x20\xd1\x82\xd0\xbe\xd1\x87\xd0\xba\xd0\xb8\x20\xd0\xbe\xd1\x82\
    \xd0\xbd\xd0\xbe\xd1\x81\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\
    \xd0\xbe\x20\xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd1\x8b\xd0\xb4\xd1\x83\xd1\
    \x89\xd0\xb5\xd0\xb9,\r\n\x20\xd0\xb2\x20\xd1\x87\xd0\xb0\xd1\x81\xd1\
    \x82\xd0\xbd\xd0\xbe\xd1\x81\xd1\x82\xd0\xb8\x20\xd0\xbf\xd0\xbe\xd1\x81\
    \xd0\xbb\xd0\xb5\xd0\xb4\xd0\xbd\xd1\x8f\xd1\x8f\x20\xd1\x82\xd0\xbe\xd1\
    \x87\xd0\xba\xd0\xb0\x20\xd1\x85\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb8\xd1\x82\
    \x20\xd1\x81\xd0\xbc\xd0\xb5\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\
    \xd1\x85\xd0\xb2\xd0\xbe\xd1\x81\xd1\x82\xd0\xb0\x20\xd0\xb7\xd0\xbc\xd0\
    \xb5\xd0\xb8\x20\xd0\xbe\xd1\x82\xd0\xbd\xd0\xbe\xd1\x81\xd0\xb8\xd1\x82\
    \xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\x20\xd0\xbf\xd1\x80\xd0\xb5\xd0\
    \xb4\xd1\x8b\xd0\xb4\xd1\x83\xd1\x89\xd0\xb5\xd0\xb9\x20\"\xd0\xba\xd0\
    \xbb\xd1\x8e\xd1\x87\xd0\xb5\xd0\xb2\xd0\xbe\xd0\xb9\"\x20\xd1\x82\xd0\
    \xbe\xd1\x87\xd0\xba\xd0\xb8.\x20\n\x0e\n\x07\x04\x03\x03\x01\x02\x01\
    \x04\x12\x03D\x08\x10\n\x0e\n\x07\x04\x03\x03\x01\x02\x01\x06\x12\x03D\
    \x11\x16\n\x0e\n\x07\x04\x03\x03\x01\x02\x01\x01\x12\x03D\x17\x1d\n\x0e\
    \n\x07\x04\x03\x03\x01\x02\x01\x03\x12\x03D\x20!\n3\n\x06\x04\x03\x03\
    \x01\x02\x02\x12\x03E\x088\"$\x20\xd1\x81\xd1\x82\xd0\xb0\xd1\x82\xd1\
    \x83\xd1\x81\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8\x20\xd0\xb2\x20\xd0\xb8\
    \xd0\xb3\xd1\x80\xd0\xb5\r\n\n\x0e\n\x07\x04\x03\x03\x01\x02\x02\x04\x12\
    \x03E\x08\x10\n\x0e\n\x07\x04\x03\x03\x01\x02\x02\x06\x12\x03E\x11\x1b\n\
    \x0e\n\x07\x04\x03\x03\x01\x02\x02\x01\x12\x03E\x1c!\n\x0e\n\x07\x04\x03\
    \x03\x01\x02\x02\x03\x12\x03E$%\n\x0e\n\x07\x04\x03\x03\x01\x02\x02\x08\
    \x12\x03E&7\n\x0e\n\x07\x04\x03\x03\x01\x02\x02\x07\x12\x03E16\n\x89\x01\
    \n\x06\x04\x03\x03\x01\x02\x03\x12\x03F\x08.\"z\x20\xd0\x9d\xd0\xb0\xd0\
    \xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5,\
    \x20\xd0\xb2\x20\xd0\xba\xd0\xbe\xd1\x82\xd0\xbe\xd1\x80\xd0\xbe\xd0\xbc\
    \x20\"\xd0\xbf\xd0\xbe\xd0\xb2\xd1\x91\xd1\x80\xd0\xbd\xd1\x83\xd1\x82\
    \xd0\xb0\"\x20\xd0\xb3\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xb0\x20\xd0\
    \xb7\xd0\xbc\xd0\xb5\xd0\xb9\xd0\xba\xd0\xb8\x20\xd0\xb2\x20\xd1\x82\xd0\
    \xb5\xd0\xba\xd1\x83\xd1\x89\xd0\xb8\xd0\xb9\x20\xd0\xbc\xd0\xbe\xd0\xbc\
    \xd0\xb5\xd0\xbd\xd1\x82\r\n\n\x0e\n\x07\x04\x03\x03\x01\x02\x03\x04\x12\
    \x03F\x08\x10\n\x0e\n\x07\x04\x03\x03\x01\x02\x03\x06\x12\x03F\x11\x1a\n\
    \x0e\n\x07\x04\x03\x03\x01\x02\x03\x01\x12\x03F\x1b)\n\x0e\n\x07\x04\x03\
    \x03\x01\x02\x03\x03\x12\x03F,-\n\x9b\x01\n\x04\x04\x03\x02\0\x12\x03H\
    \x04#\"\x8d\x01\x20\xd0\x9f\xd0\xbe\xd1\x80\xd1\x8f\xd0\xb4\xd0\xba\xd0\
    \xbe\xd0\xb2\xd1\x8b\xd0\xb9\x20\xd0\xbd\xd0\xbe\xd0\xbc\xd0\xb5\xd1\x80\
    \x20\xd1\x81\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd1\x8f\xd0\xbd\xd0\xb8\xd1\
    \x8f,\x20\xd1\x83\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\xd0\xb5\xd0\
    \xbd\x20\xd0\xb2\x20\xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd0\
    \xb0\xd1\x85\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b,\x20\xd0\xbc\xd0\xbe\
    \xd0\xbd\xd0\xbe\xd1\x82\xd0\xbe\xd0\xbd\xd0\xbd\xd0\xbe\x20\xd0\xb2\xd0\
    \xbe\xd0\xb7\xd1\x80\xd0\xb0\xd1\x81\xd1\x82\xd0\xb0\xd0\xb5\xd1\x82\r\n\
    \n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03H\x04\x0c\n\x0c\n\x05\x04\x03\x02\
    \0\x05\x12\x03H\r\x12\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03H\x13\x1e\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x03H!\"\n%\n\x04\x04\x03\x02\x01\x12\
    \x03I\x04\x1e\"\x18\x20\xd0\xa1\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba\
    \x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb9\r\n\n\x0c\n\x05\x04\x03\x02\x01\x04\
    \x12\x03I\x04\x0c\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03I\r\x12\n\x0c\n\
    \x05\x04\x03\x02\x01\x01\x12\x03I\x13\x19\n\x0c\n\x05\x04\x03\x02\x01\
    \x03\x12\x03I\x1c\x1d\n5\n\x04\x04\x03\x02\x02\x12\x03J\x04\x1d\"(\x20\
    \xd0\xa1\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba\x20\xd0\xba\xd0\xbb\xd0\
    \xb5\xd1\x82\xd0\xbe\xd0\xba\x20\xd1\x81\x20\xd0\xb5\xd0\xb4\xd0\xbe\xd0\
    \xb9\r\n\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03J\x04\x0c\n\x0c\n\x05\
    \x04\x03\x02\x02\x06\x12\x03J\r\x12\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\
    \x03J\x13\x18\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03J\x1b\x1c\nF\n\x04\
    \x04\x03\x02\x03\x12\x03K\x04%\"9\x20\xd0\x90\xd0\xba\xd1\x82\xd1\x83\
    \xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xb5\xd0\xb9\xd1\x88\xd0\xb8\xd0\xb9\
    \x20\xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba\x20\xd0\xb8\xd0\xb3\
    \xd1\x80\xd0\xbe\xd0\xba\xd0\xbe\xd0\xb2\r\n\n\x0c\n\x05\x04\x03\x02\x03\
    \x04\x12\x03K\x04\x0c\n\x0c\n\x05\x04\x03\x02\x03\x06\x12\x03K\r\x18\n\
    \x0c\n\x05\x04\x03\x02\x03\x01\x12\x03K\x19\x20\n\x0c\n\x05\x04\x03\x02\
    \x03\x03\x12\x03K#$\n\n\n\x02\x04\x04\x12\x04N\0S\x01\n\n\n\x03\x04\x04\
    \x01\x12\x03N\x08\x18\n+\n\x04\x04\x04\x02\0\x12\x03O\x04%\"\x1e\x20\xd0\
    \xa2\xd0\xb5\xd0\xba\xd1\x83\xd1\x89\xd0\xb8\xd0\xb5\x20\xd0\xb8\xd0\xb3\
    \xd1\x80\xd0\xbe\xd0\xba\xd0\xb8\r\n\n\x0c\n\x05\x04\x04\x02\0\x04\x12\
    \x03O\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03O\r\x18\n\x0c\n\x05\
    \x04\x04\x02\0\x01\x12\x03O\x19\x20\n\x0c\n\x05\x04\x04\x02\0\x03\x12\
    \x03O#$\n+\n\x04\x04\x04\x02\x01\x12\x03P\x04#\"\x1e\x20\xd0\x9f\xd0\xb0\
    \xd1\x80\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x82\xd1\x80\xd1\x8b\x20\xd0\xb8\xd0\
    \xb3\xd1\x80\xd1\x8b\r\n\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03P\x04\
    \x0c\n\x0c\n\x05\x04\x04\x02\x01\x06\x12\x03P\r\x17\n\x0c\n\x05\x04\x04\
    \x02\x01\x01\x12\x03P\x18\x1e\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03P!\
    \"\n\x8b\x01\n\x04\x04\x04\x02\x02\x12\x03Q\x040\"~\x20\xd0\x9c\xd0\xbe\
    \xd0\xb6\xd0\xbd\xd0\xbe\x20\xd0\xbb\xd0\xb8\x20\xd0\xbd\xd0\xbe\xd0\xb2\
    \xd0\xbe\xd0\xbc\xd1\x83\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd1\
    \x83\x20\xd0\xbf\xd1\x80\xd0\xb8\xd1\x81\xd0\xbe\xd0\xb5\xd0\xb4\xd0\xb8\
    \xd0\xbd\xd0\xb8\xd1\x82\xd1\x8c\xd1\x81\xd1\x8f\x20\xd0\xba\x20\xd0\xb8\
    \xd0\xb3\xd1\x80\xd0\xb5\x20(\xd0\xb5\xd1\x81\xd1\x82\xd1\x8c\x20\xd0\
    \xbb\xd0\xb8\x20\xd0\xbc\xd0\xb5\xd1\x81\xd1\x82\xd0\xbe\x20\xd0\xbd\xd0\
    \xb0\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd0\xb5)\r\n\n\x0c\n\x05\x04\x04\x02\
    \x02\x04\x12\x03Q\x04\x0c\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03Q\r\x11\
    \n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03Q\x12\x1a\n\x0c\n\x05\x04\x04\
    \x02\x02\x03\x12\x03Q\x1d\x1e\n\x0c\n\x05\x04\x04\x02\x02\x08\x12\x03Q\
    \x1f/\n\x0c\n\x05\x04\x04\x02\x02\x07\x12\x03Q*.\nc\n\x04\x04\x04\x02\
    \x03\x12\x03R\x04\"\"V\x20\xd0\x93\xd0\xbb\xd0\xbe\xd0\xb1\xd0\xb0\xd0\
    \xbb\xd1\x8c\xd0\xbd\xd0\xbe\x20\xd1\x83\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\
    \xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\xd0\xb5\x20\xd0\xb8\xd0\xbc\xd1\x8f\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b,\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\
    \xd0\xb8\xd0\xbc\xd0\xb5\xd1\x80\x20\"my\x20game\"\r\n\n\x0c\n\x05\x04\
    \x04\x02\x03\x04\x12\x03R\x04\x0c\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\
    \x03R\r\x13\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03R\x14\x1d\n\x0c\n\x05\
    \x04\x04\x02\x03\x03\x12\x03R\x20!\nK\n\x02\x04\x05\x12\x05V\0\x91\x01\
    \x01\x1a>\x20\xd0\x9e\xd0\xb1\xd1\x89\xd0\xb8\xd0\xb9\x20\xd1\x84\xd0\
    \xbe\xd1\x80\xd0\xbc\xd0\xb0\xd1\x82\x20\xd0\xbb\xd1\x8e\xd0\xb1\xd0\xbe\
    \xd0\xb3\xd0\xbe\x20UDP-\xd1\x81\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\
    \xd0\xbd\xd0\xb8\xd1\x8f\r\n\n\n\n\x03\x04\x05\x01\x12\x03V\x08\x13\nb\n\
    \x04\x04\x05\x03\0\x12\x04X\x04Y\x05\x1aT\x20\xd0\x9d\xd0\xb8\xd1\x87\
    \xd0\xb5\xd0\xb3\xd0\xbe\x20\xd0\xbd\xd0\xb5\x20\xd0\xbc\xd0\xb5\xd0\xbd\
    \xd1\x8f\xd0\xb5\xd0\xbc,\x20\xd0\xbf\xd1\x80\xd0\xbe\xd1\x81\xd1\x82\
    \xd0\xbe\x20\xd0\xb3\xd0\xbe\xd0\xb2\xd0\xbe\xd1\x80\xd0\xb8\xd0\xbc,\
    \x20\xd1\x87\xd1\x82\xd0\xbe\x20\xd0\xbc\xd1\x8b\x20\xd0\xb6\xd0\xb8\xd0\
    \xb2\xd1\x8b\r\n\n\x0c\n\x05\x04\x05\x03\0\x01\x12\x03X\x0c\x13\nm\n\x04\
    \x04\x05\x03\x01\x12\x04[\x04]\x05\x1a_\x20\xd0\x9d\xd0\xb5-\xd1\x86\xd0\
    \xb5\xd0\xbd\xd1\x82\xd1\x80\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x8b\xd0\
    \xb9\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\x20\xd0\xbf\xd1\x80\xd0\
    \xbe\xd1\x81\xd0\xb8\xd1\x82\x20\xd0\xbf\xd0\xbe\xd0\xb2\xd0\xb5\xd1\x80\
    \xd0\xbd\xd1\x83\xd1\x82\xd1\x8c\x20\xd0\xb3\xd0\xbe\xd0\xbb\xd0\xbe\xd0\
    \xb2\xd1\x83\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8\r\n\n\x0c\n\x05\x04\x05\
    \x03\x01\x01\x12\x03[\x0c\x14\nN\n\x06\x04\x05\x03\x01\x02\0\x12\x03\\\
    \x08)\"?\x20\xd0\x9a\xd1\x83\xd0\xb4\xd0\xb0\x20\xd0\xbf\xd0\xbe\xd0\xb2\
    \xd0\xb5\xd1\x80\xd0\xbd\xd1\x83\xd1\x82\xd1\x8c\x20\xd0\xbd\xd0\xb0\x20\
    \xd1\x81\xd0\xbb\xd0\xb5\xd0\xb4\xd1\x83\xd1\x8e\xd1\x89\xd0\xb5\xd0\xbc\
    \x20\xd1\x88\xd0\xb0\xd0\xb3\xd0\xb5\r\n\n\x0e\n\x07\x04\x05\x03\x01\x02\
    \0\x04\x12\x03\\\x08\x10\n\x0e\n\x07\x04\x05\x03\x01\x02\0\x06\x12\x03\\\
    \x11\x1a\n\x0e\n\x07\x04\x05\x03\x01\x02\0\x01\x12\x03\\\x1b$\n\x0e\n\
    \x07\x04\x05\x03\x01\x02\0\x03\x12\x03\\'(\nU\n\x04\x04\x05\x03\x02\x12\
    \x04_\x04`\x05\x1aG\x20\xd0\x9f\xd0\xbe\xd0\xb4\xd1\x82\xd0\xb2\xd0\xb5\
    \xd1\x80\xd0\xb6\xd0\xb4\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\xd1\x81\xd0\
    \xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\x20\xd1\x81\
    \x20\xd1\x82\xd0\xb0\xd0\xba\xd0\xb8\xd0\xbc\x20\xd0\xb6\xd0\xb5\x20seq\
    \r\n\n\x0c\n\x05\x04\x05\x03\x02\x01\x12\x03_\x0c\x12\n\x7f\n\x04\x04\
    \x05\x03\x03\x12\x04b\x04d\x05\x1aq\x20\xd0\xa6\xd0\xb5\xd0\xbd\xd1\x82\
    \xd1\x80\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x8b\xd0\xb9\x20\xd1\x83\xd0\
    \xb7\xd0\xb5\xd0\xbb\x20\xd1\x81\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb0\
    \xd0\xb5\xd1\x82\x20\xd0\xbe\xd1\x81\xd1\x82\xd0\xb0\xd0\xbb\xd1\x8c\xd0\
    \xbd\xd1\x8b\xd0\xbc\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\
    \xd0\xbc\x20\xd1\x81\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd1\x8f\xd0\xbd\xd0\
    \xb8\xd0\xb5\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b\r\n\n\x0c\n\x05\x04\x05\
    \x03\x03\x01\x12\x03b\x0c\x14\n>\n\x06\x04\x05\x03\x03\x02\0\x12\x03c\
    \x08%\"/\x20\xd0\xa1\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd1\x8f\xd0\xbd\xd0\
    \xb8\xd0\xb5\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xb2\xd0\xbe\xd0\xb3\
    \xd0\xbe\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f\r\n\n\x0e\n\x07\x04\x05\x03\
    \x03\x02\0\x04\x12\x03c\x08\x10\n\x0e\n\x07\x04\x05\x03\x03\x02\0\x06\
    \x12\x03c\x11\x1a\n\x0e\n\x07\x04\x05\x03\x03\x02\0\x01\x12\x03c\x1b\x20\
    \n\x0e\n\x07\x04\x05\x03\x03\x02\0\x03\x12\x03c#$\n\xa7\x01\n\x04\x04\
    \x05\x03\x04\x12\x04f\x04h\x05\x1a\x98\x01\x20\xd0\xa3\xd0\xb2\xd0\xb5\
    \xd0\xb4\xd0\xbe\xd0\xbc\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\xd0\
    \xbe\xd0\xb1\x20\xd0\xb8\xd0\xb4\xd1\x83\xd1\x89\xd0\xb8\xd1\x85\x20\xd0\
    \xb8\xd0\xb3\xd1\x80\xd0\xb0\xd1\x85,\x20\xd1\x80\xd0\xb5\xd0\xb3\xd1\
    \x83\xd0\xbb\xd1\x8f\xd1\x80\xd0\xbd\xd0\xbe\x20\xd0\xbe\xd1\x82\xd0\xbf\
    \xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\xd1\x8f\xd0\xb5\xd1\x82\xd1\x81\xd1\x8f\
    \x20multicast-\xd0\xbe\xd0\xbc\x20\xd0\xb8\xd0\xbb\xd0\xb8\x20\xd0\xb2\
    \x20\xd0\xbe\xd1\x82\xd0\xb2\xd0\xb5\xd1\x82\x20\xd0\xbd\xd0\xb0\x20Disc\
    overMsg\r\n\n\x0c\n\x05\x04\x05\x03\x04\x01\x12\x03f\x0c\x1b\n\x86\x01\n\
    \x06\x04\x05\x03\x04\x02\0\x12\x03g\x08,\"w\x20\xd0\x98\xd0\xb4\xd1\x83\
    \xd1\x89\xd0\xb8\xd0\xb5\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b\x20(\xd0\
    \xb2\x20\xd1\x82\xd0\xb5\xd0\xba\xd1\x83\xd1\x89\xd0\xb5\xd0\xb9\x20\xd0\
    \xb2\xd0\xb5\xd1\x80\xd1\x81\xd0\xb8\xd0\xb8\x20\xd0\xb7\xd0\xb0\xd0\xb4\
    \xd0\xb0\xd1\x87\xd0\xb8\x20\xd1\x82\xd1\x83\xd1\x82\x20\xd0\xb2\xd1\x81\
    \xd0\xb5\xd0\xb3\xd0\xb4\xd0\xb0\x20\xd1\x80\xd0\xbe\xd0\xb2\xd0\xbd\xd0\
    \xbe\x20\xd0\xbe\xd0\xb4\xd0\xbd\xd0\xb0\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\
    \xb0)\r\n\n\x0e\n\x07\x04\x05\x03\x04\x02\0\x04\x12\x03g\x08\x10\n\x0e\n\
    \x07\x04\x05\x03\x04\x02\0\x06\x12\x03g\x11!\n\x0e\n\x07\x04\x05\x03\x04\
    \x02\0\x01\x12\x03g\"'\n\x0e\n\x07\x04\x05\x03\x04\x02\0\x03\x12\x03g*+\
    \nO\n\x04\x04\x05\x03\x05\x12\x04j\x04k\x05\x1aA\x20\xd0\x97\xd0\xb0\xd0\
    \xbf\xd1\x80\xd0\xbe\xd1\x81\x20\xd0\xb8\xd0\xbd\xd1\x84\xd0\xbe\xd1\x80\
    \xd0\xbc\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8\x20\xd0\xbe\xd0\xb1\x20\xd0\xb8\
    \xd0\xb4\xd1\x83\xd1\x89\xd0\xb8\xd1\x85\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\
    \xb0\xd1\x85\r\n\n\x0c\n\x05\x04\x05\x03\x05\x01\x12\x03j\x0c\x17\ng\n\
    \x04\x04\x05\x03\x06\x12\x04m\x04r\x05\x1aY\x20\xd0\x9d\xd0\xbe\xd0\xb2\
    \xd1\x8b\xd0\xb9\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\x20\xd1\x85\
    \xd0\xbe\xd1\x87\xd0\xb5\xd1\x82\x20\xd0\xbf\xd1\x80\xd0\xb8\xd1\x81\xd0\
    \xbe\xd0\xb5\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb8\xd1\x82\xd1\x8c\xd1\x81\xd1\
    \x8f\x20\xd0\xba\x20\xd0\xb8\xd0\xb4\xd1\x83\xd1\x89\xd0\xb5\xd0\xb9\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd0\xb5\r\n\n\x0c\n\x05\x04\x05\x03\x06\x01\x12\
    \x03m\x0c\x13\nH\n\x06\x04\x05\x03\x06\x02\0\x12\x03n\x08>\"9\x20\xd0\
    \xa2\xd0\xb8\xd0\xbf\x20\xd0\xbf\xd1\x80\xd0\xb8\xd1\x81\xd0\xbe\xd0\xb5\
    \xd0\xb4\xd0\xb8\xd0\xbd\xd1\x8f\xd1\x8e\xd1\x89\xd0\xb5\xd0\xb3\xd0\xbe\
    \xd1\x81\xd1\x8f\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\r\n\
    \n\x0e\n\x07\x04\x05\x03\x06\x02\0\x04\x12\x03n\x08\x10\n\x0e\n\x07\x04\
    \x05\x03\x06\x02\0\x06\x12\x03n\x11\x1b\n\x0e\n\x07\x04\x05\x03\x06\x02\
    \0\x01\x12\x03n\x1c'\n\x0e\n\x07\x04\x05\x03\x06\x02\0\x03\x12\x03n*+\n\
    \x0e\n\x07\x04\x05\x03\x06\x02\0\x08\x12\x03n,=\n\x0e\n\x07\x04\x05\x03\
    \x06\x02\0\x07\x12\x03n7<\n%\n\x06\x04\x05\x03\x06\x02\x01\x12\x03o\x08(\
    \"\x16\x20\xd0\x98\xd0\xbc\xd1\x8f\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\
    \xd0\xba\xd0\xb0\r\n\n\x0e\n\x07\x04\x05\x03\x06\x02\x01\x04\x12\x03o\
    \x08\x10\n\x0e\n\x07\x04\x05\x03\x06\x02\x01\x05\x12\x03o\x11\x17\n\x0e\
    \n\x07\x04\x05\x03\x06\x02\x01\x01\x12\x03o\x18#\n\x0e\n\x07\x04\x05\x03\
    \x06\x02\x01\x03\x12\x03o&'\n\x84\x01\n\x06\x04\x05\x03\x06\x02\x02\x12\
    \x03p\x08&\"u\x20\xd0\x93\xd0\xbb\xd0\xbe\xd0\xb1\xd0\xb0\xd0\xbb\xd1\
    \x8c\xd0\xbd\xd0\xbe\x20\xd1\x83\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\
    \xd1\x8c\xd0\xbd\xd0\xbe\xd0\xb5\x20\xd0\xb8\xd0\xbc\xd1\x8f\x20\xd0\xb8\
    \xd0\xb3\xd1\x80\xd1\x8b,\x20\xd0\xba\x20\xd0\xba\xd0\xbe\xd1\x82\xd0\
    \xbe\xd1\x80\xd0\xbe\xd0\xb9\x20\xd1\x85\xd0\xbe\xd1\x82\xd0\xb8\xd0\xbc\
    \x20\xd0\xbf\xd1\x80\xd0\xb8\xd1\x81\xd0\xbe\xd0\xb5\xd0\xb4\xd0\xb8\xd0\
    \xbd\xd0\xb8\xd1\x82\xd1\x8c\xd1\x81\xd1\x8f\r\n\n\x0e\n\x07\x04\x05\x03\
    \x06\x02\x02\x04\x12\x03p\x08\x10\n\x0e\n\x07\x04\x05\x03\x06\x02\x02\
    \x05\x12\x03p\x11\x17\n\x0e\n\x07\x04\x05\x03\x06\x02\x02\x01\x12\x03p\
    \x18!\n\x0e\n\x07\x04\x05\x03\x06\x02\x02\x03\x12\x03p$%\n\xb8\x01\n\x06\
    \x04\x05\x03\x06\x02\x03\x12\x03q\x08-\"\xa8\x01\x20NORMAL,\x20\xd0\xb5\
    \xd1\x81\xd0\xbb\xd0\xb8\x20\xd1\x85\xd0\xbe\xd1\x82\xd0\xb8\xd0\xbc\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd0\xb0\xd1\x82\xd1\x8c;\x20VIEWER,\x20\xd0\xb5\
    \xd1\x81\xd0\xbb\xd0\xb8\x20\xd1\x85\xd0\xbe\xd1\x82\xd0\xb8\xd0\xbc\x20\
    \xd1\x82\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xba\xd0\xbe\x20\xd0\xbf\xd0\xbe\xd0\
    \xbd\xd0\xb0\xd0\xb1\xd0\xbb\xd1\x8e\xd0\xb4\xd0\xb0\xd1\x82\xd1\x8c;\
    \x20\xd0\xbe\xd1\x81\xd1\x82\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x8b\xd0\
    \xb5\x20\xd0\xb7\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\
    \x20\xd0\xbd\xd0\xb5\xd0\xb4\xd0\xbe\xd0\xbf\xd1\x83\xd1\x81\xd1\x82\xd0\
    \xb8\xd0\xbc\xd1\x8b\r\n\n\x0e\n\x07\x04\x05\x03\x06\x02\x03\x04\x12\x03\
    q\x08\x10\n\x0e\n\x07\x04\x05\x03\x06\x02\x03\x06\x12\x03q\x11\x19\n\x0e\
    \n\x07\x04\x05\x03\x06\x02\x03\x01\x12\x03q\x1a(\n\x0e\n\x07\x04\x05\x03\
    \x06\x02\x03\x03\x12\x03q+,\n\x9f\x01\n\x04\x04\x05\x03\x07\x12\x04t\x04\
    v\x05\x1a\x90\x01\x20\xd0\x9e\xd1\x88\xd0\xb8\xd0\xb1\xd0\xba\xd0\xb0\
    \x20\xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8\x20\
    (\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb8\xd0\xbc\xd0\xb5\xd1\x80\x20\
    \xd0\xbe\xd1\x82\xd0\xba\xd0\xb0\xd0\xb7\x20\xd0\xb2\x20\xd0\xbf\xd1\x80\
    \xd0\xb8\xd1\x81\xd0\xbe\xd0\xb5\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb5\xd0\xbd\
    \xd0\xb8\xd0\xb8\x20\xd0\xba\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xb5,\x20\
    \xd1\x82.\xd0\xba.\x20\xd0\xbd\xd0\xb5\xd1\x82\x20\xd0\xbc\xd0\xb5\xd1\
    \x81\xd1\x82\xd0\xb0\x20\xd0\xbd\xd0\xb0\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd0\
    \xb5)\r\n\n\x0c\n\x05\x04\x05\x03\x07\x01\x12\x03t\x0c\x14\n\xa9\x01\n\
    \x06\x04\x05\x03\x07\x02\0\x12\x03u\x08*\"\x99\x01\x20\xd0\xa1\xd1\x82\
    \xd1\x80\xd0\xbe\xd0\xba\xd0\xbe\xd0\xb2\xd0\xbe\xd0\xb5\x20\xd1\x81\xd0\
    \xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5,\x20\xd0\
    \xbd\xd1\x83\xd0\xb6\xd0\xbd\xd0\xbe\x20\xd0\xbe\xd1\x82\xd0\xbe\xd0\xb1\
    \xd1\x80\xd0\xb0\xd0\xb7\xd0\xb8\xd1\x82\xd1\x8c\x20\xd0\xb5\xd0\xb3\xd0\
    \xbe\x20\xd0\xbd\xd0\xb0\x20\xd1\x8d\xd0\xba\xd1\x80\xd0\xb0\xd0\xbd\xd0\
    \xb5,\x20\xd0\xbd\xd0\xb5\x20\xd0\xb1\xd0\xbb\xd0\xbe\xd0\xba\xd0\xb8\
    \xd1\x80\xd1\x83\xd1\x8f\x20\xd1\x80\xd0\xb0\xd0\xb1\xd0\xbe\xd1\x82\xd1\
    \x83\x20\xd0\xbf\xd1\x80\xd0\xbe\xd0\xb3\xd1\x80\xd0\xb0\xd0\xbc\xd0\xbc\
    \xd1\x8b\r\n\n\x0e\n\x07\x04\x05\x03\x07\x02\0\x04\x12\x03u\x08\x10\n\
    \x0e\n\x07\x04\x05\x03\x07\x02\0\x05\x12\x03u\x11\x17\n\x0e\n\x07\x04\
    \x05\x03\x07\x02\0\x01\x12\x03u\x18%\n\x0e\n\x07\x04\x05\x03\x07\x02\0\
    \x03\x12\x03u()\n\xd7\x05\n\x04\x04\x05\x03\x08\x12\x05~\x04\x81\x01\x05\
    \x1a\xc7\x05\x20\xd0\xa1\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\
    \xd0\xb8\xd0\xb5\x20\xd0\xbe\x20\xd1\x81\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xb5\
    \x20\xd1\x80\xd0\xbe\xd0\xbb\xd0\xb8:\r\n\x201.\x20\xd0\xbe\xd1\x82\x20\
    \xd0\xb7\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x81\xd1\x82\xd0\xb8\xd1\x82\xd0\xb5\
    \xd0\xbb\xd1\x8f\x20\xd0\xb4\xd1\x80\xd1\x83\xd0\xb3\xd0\xb8\xd0\xbc\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\xd0\xbc\x20\xd0\xbe\x20\
    \xd1\x82\xd0\xbe\xd0\xbc,\x20\xd1\x87\xd1\x82\xd0\xbe\x20\xd0\xbf\xd0\
    \xbe\xd1\x80\xd0\xb0\x20\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb8\xd0\xbd\xd0\xb0\
    \xd1\x82\xd1\x8c\x20\xd1\x81\xd1\x87\xd0\xb8\xd1\x82\xd0\xb0\xd1\x82\xd1\
    \x8c\x20\xd0\xb5\xd0\xb3\xd0\xbe\x20\xd0\xb3\xd0\xbb\xd0\xb0\xd0\xb2\xd0\
    \xbd\xd1\x8b\xd0\xbc\x20(sender_role\x20=\x20MASTER)\r\n\x202.\x20\xd0\
    \xbe\xd1\x82\x20\xd0\xbe\xd1\x81\xd0\xbe\xd0\xb7\xd0\xbd\xd0\xb0\xd0\xbd\
    \xd0\xbd\xd0\xbe\x20\xd0\xb2\xd1\x8b\xd1\x85\xd0\xbe\xd0\xb4\xd1\x8f\xd1\
    \x89\xd0\xb5\xd0\xb3\xd0\xbe\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\
    \xd0\xb0\x20(sender_role\x20=\x20VIEWER)\r\n\x203.\x20\xd0\xbe\xd1\x82\
    \x20\xd0\xb3\xd0\xbb\xd0\xb0\xd0\xb2\xd0\xbd\xd0\xbe\xd0\xb3\xd0\xbe\x20\
    \xd0\xba\x20\xd1\x83\xd0\xbc\xd0\xb5\xd1\x80\xd1\x88\xd0\xb5\xd0\xbc\xd1\
    \x83\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd1\x83\x20(receiver_ro\
    le\x20=\x20VIEWER)\r\n\x204.\x20\xd0\xb2\x20\xd0\xba\xd0\xbe\xd0\xbc\xd0\
    \xb1\xd0\xb8\xd0\xbd\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8\x20\xd1\x81\x201,2\
    \x20\xd0\xb8\xd0\xbb\xd0\xb8\x20\xd0\xbe\xd1\x82\xd0\xb4\xd0\xb5\xd0\xbb\
    \xd1\x8c\xd0\xbd\xd0\xbe\x20\xd0\xbe\xd1\x82\x20\xd0\xbd\xd0\xb8\xd1\x85\
    :\x20\xd0\xbd\xd0\xb0\xd0\xb7\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb5\xd0\xbd\
    \xd0\xb8\xd0\xb5\x20\xd0\xba\xd0\xbe\xd0\xb3\xd0\xbe-\xd1\x82\xd0\xbe\
    \x20\xd0\xb7\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x81\xd1\x82\xd0\xb8\xd1\x82\xd0\
    \xb5\xd0\xbb\xd0\xb5\xd0\xbc\x20(receiver_role\x20=\x20DEPUTY)\r\n\x205.\
    \x20\xd0\xb2\x20\xd0\xba\xd0\xbe\xd0\xbc\xd0\xb1\xd0\xb8\xd0\xbd\xd0\xb0\
    \xd1\x86\xd0\xb8\xd0\xb8\x20\xd1\x81\x202\x20\xd0\xbe\xd1\x82\x20\xd0\
    \xb3\xd0\xbb\xd0\xb0\xd0\xb2\xd0\xbd\xd0\xbe\xd0\xb3\xd0\xbe\x20\xd1\x83\
    \xd0\xb7\xd0\xbb\xd0\xb0\x20\xd0\xb7\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x81\xd1\
    \x82\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8e\x20\xd0\xbe\x20\xd1\x82\xd0\
    \xbe\xd0\xbc,\x20\xd1\x87\xd1\x82\xd0\xbe\x20\xd0\xbe\xd0\xbd\x20\xd1\
    \x81\xd1\x82\xd0\xb0\xd0\xbd\xd0\xbe\xd0\xb2\xd0\xb8\xd1\x82\xd1\x81\xd1\
    \x8f\x20\xd0\xb3\xd0\xbb\xd0\xb0\xd0\xb2\xd0\xbd\xd1\x8b\xd0\xbc\x20(rec\
    eiver_role\x20=\x20MASTER)\r\n\n\x0c\n\x05\x04\x05\x03\x08\x01\x12\x03~\
    \x0c\x19\n\r\n\x06\x04\x05\x03\x08\x02\0\x12\x03\x7f\x08*\n\x0e\n\x07\
    \x04\x05\x03\x08\x02\0\x04\x12\x03\x7f\x08\x10\n\x0e\n\x07\x04\x05\x03\
    \x08\x02\0\x06\x12\x03\x7f\x11\x19\n\x0e\n\x07\x04\x05\x03\x08\x02\0\x01\
    \x12\x03\x7f\x1a%\n\x0e\n\x07\x04\x05\x03\x08\x02\0\x03\x12\x03\x7f()\n\
    \x0e\n\x06\x04\x05\x03\x08\x02\x01\x12\x04\x80\x01\x08,\n\x0f\n\x07\x04\
    \x05\x03\x08\x02\x01\x04\x12\x04\x80\x01\x08\x10\n\x0f\n\x07\x04\x05\x03\
    \x08\x02\x01\x06\x12\x04\x80\x01\x11\x19\n\x0f\n\x07\x04\x05\x03\x08\x02\
    \x01\x01\x12\x04\x80\x01\x1a'\n\x0f\n\x07\x04\x05\x03\x08\x02\x01\x03\
    \x12\x04\x80\x01*+\n\xba\x01\n\x04\x04\x05\x02\0\x12\x04\x82\x01\x04\x1f\
    \"\xab\x01\x20\xd0\x9f\xd0\xbe\xd1\x80\xd1\x8f\xd0\xb4\xd0\xba\xd0\xbe\
    \xd0\xb2\xd1\x8b\xd0\xb9\x20\xd0\xbd\xd0\xbe\xd0\xbc\xd0\xb5\xd1\x80\x20\
    \xd1\x81\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\
    ,\x20\xd1\x83\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\xd0\xb5\xd0\xbd\
    \x20\xd0\xb4\xd0\xbb\xd1\x8f\x20\xd0\xbe\xd1\x82\xd0\xbf\xd1\x80\xd0\xb0\
    \xd0\xb2\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8f\x20\xd0\xb2\x20\xd0\xbf\
    \xd1\x80\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x85\x20\xd0\xb8\xd0\
    \xb3\xd1\x80\xd1\x8b,\x20\xd0\xbc\xd0\xbe\xd0\xbd\xd0\xbe\xd1\x82\xd0\
    \xbe\xd0\xbd\xd0\xbd\xd0\xbe\x20\xd0\xb2\xd0\xbe\xd0\xb7\xd1\x80\xd0\xb0\
    \xd1\x81\xd1\x82\xd0\xb0\xd0\xb5\xd1\x82\r\n\n\r\n\x05\x04\x05\x02\0\x04\
    \x12\x04\x82\x01\x04\x0c\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\x82\x01\r\
    \x12\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x82\x01\x13\x1a\n\r\n\x05\x04\
    \x05\x02\0\x03\x12\x04\x82\x01\x1d\x1e\n\x8d\x01\n\x04\x04\x05\x02\x01\
    \x12\x04\x83\x01\x04\"\"\x7f\x20ID\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\
    \xd0\xba\xd0\xb0-\xd0\xbe\xd1\x82\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\
    \xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8f\x20\xd1\x8d\xd1\x82\xd0\xbe\xd0\xb3\
    \xd0\xbe\x20\xd1\x81\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\
    \xb8\xd1\x8f\x20(\xd0\xbe\xd0\xb1\xd1\x8f\xd0\xb7\xd0\xb0\xd1\x82\xd0\
    \xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\x20\xd0\xb4\xd0\xbb\xd1\x8f\x20AckM\
    sg\x20\xd0\xb8\x20RoleChangeMsg)\r\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\
    \x04\x83\x01\x04\x0c\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\x83\x01\r\x12\
    \n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x83\x01\x13\x1c\n\r\n\x05\x04\x05\
    \x02\x01\x03\x12\x04\x83\x01\x1f!\n\x8b\x01\n\x04\x04\x05\x02\x02\x12\
    \x04\x84\x01\x04$\"}\x20ID\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\
    \xd0\xb0-\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\xd1\x82\xd0\
    \xb5\xd0\xbb\xd1\x8f\x20\xd1\x8d\xd1\x82\xd0\xbe\xd0\xb3\xd0\xbe\x20\xd1\
    \x81\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\x20\
    (\xd0\xbe\xd0\xb1\xd1\x8f\xd0\xb7\xd0\xb0\xd1\x82\xd0\xb5\xd0\xbb\xd1\
    \x8c\xd0\xbd\xd0\xbe\x20\xd0\xb4\xd0\xbb\xd1\x8f\x20AckMsg\x20\xd0\xb8\
    \x20RoleChangeMsg)\r\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\x84\x01\x04\
    \x0c\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\x84\x01\r\x12\n\r\n\x05\x04\
    \x05\x02\x02\x01\x12\x04\x84\x01\x13\x1e\n\r\n\x05\x04\x05\x02\x02\x03\
    \x12\x04\x84\x01!#\n,\n\x04\x04\x05\x08\0\x12\x06\x86\x01\x04\x90\x01\
    \x05\x1a\x1c\x20\xd0\xa2\xd0\xb8\xd0\xbf\x20\xd1\x81\xd0\xbe\xd0\xbe\xd0\
    \xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\r\n\n\r\n\x05\x04\x05\x08\0\
    \x01\x12\x04\x86\x01\n\x0e\n\x0c\n\x04\x04\x05\x02\x03\x12\x04\x87\x01\
    \x08\x19\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\x87\x01\x08\x0f\n\r\n\x05\
    \x04\x05\x02\x03\x01\x12\x04\x87\x01\x10\x14\n\r\n\x05\x04\x05\x02\x03\
    \x03\x12\x04\x87\x01\x17\x18\n\x0c\n\x04\x04\x05\x02\x04\x12\x04\x88\x01\
    \x08\x1b\n\r\n\x05\x04\x05\x02\x04\x06\x12\x04\x88\x01\x08\x10\n\r\n\x05\
    \x04\x05\x02\x04\x01\x12\x04\x88\x01\x11\x16\n\r\n\x05\x04\x05\x02\x04\
    \x03\x12\x04\x88\x01\x19\x1a\n\x0c\n\x04\x04\x05\x02\x05\x12\x04\x89\x01\
    \x08\x17\n\r\n\x05\x04\x05\x02\x05\x06\x12\x04\x89\x01\x08\x0e\n\r\n\x05\
    \x04\x05\x02\x05\x01\x12\x04\x89\x01\x0f\x12\n\r\n\x05\x04\x05\x02\x05\
    \x03\x12\x04\x89\x01\x15\x16\n\x0c\n\x04\x04\x05\x02\x06\x12\x04\x8a\x01\
    \x08\x1b\n\r\n\x05\x04\x05\x02\x06\x06\x12\x04\x8a\x01\x08\x10\n\r\n\x05\
    \x04\x05\x02\x06\x01\x12\x04\x8a\x01\x11\x16\n\r\n\x05\x04\x05\x02\x06\
    \x03\x12\x04\x8a\x01\x19\x1a\n\x0c\n\x04\x04\x05\x02\x07\x12\x04\x8b\x01\
    \x08)\n\r\n\x05\x04\x05\x02\x07\x06\x12\x04\x8b\x01\x08\x17\n\r\n\x05\
    \x04\x05\x02\x07\x01\x12\x04\x8b\x01\x18$\n\r\n\x05\x04\x05\x02\x07\x03\
    \x12\x04\x8b\x01'(\n\x0c\n\x04\x04\x05\x02\x08\x12\x04\x8c\x01\x08\x19\n\
    \r\n\x05\x04\x05\x02\x08\x06\x12\x04\x8c\x01\x08\x0f\n\r\n\x05\x04\x05\
    \x02\x08\x01\x12\x04\x8c\x01\x10\x14\n\r\n\x05\x04\x05\x02\x08\x03\x12\
    \x04\x8c\x01\x17\x18\n\x0c\n\x04\x04\x05\x02\t\x12\x04\x8d\x01\x08\x1b\n\
    \r\n\x05\x04\x05\x02\t\x06\x12\x04\x8d\x01\x08\x10\n\r\n\x05\x04\x05\x02\
    \t\x01\x12\x04\x8d\x01\x11\x16\n\r\n\x05\x04\x05\x02\t\x03\x12\x04\x8d\
    \x01\x19\x1a\n\x0c\n\x04\x04\x05\x02\n\x12\x04\x8e\x01\x08&\n\r\n\x05\
    \x04\x05\x02\n\x06\x12\x04\x8e\x01\x08\x15\n\r\n\x05\x04\x05\x02\n\x01\
    \x12\x04\x8e\x01\x16!\n\r\n\x05\x04\x05\x02\n\x03\x12\x04\x8e\x01$%\n\
    \x0c\n\x04\x04\x05\x02\x0b\x12\x04\x8f\x01\x08\"\n\r\n\x05\x04\x05\x02\
    \x0b\x06\x12\x04\x8f\x01\x08\x13\n\r\n\x05\x04\x05\x02\x0b\x01\x12\x04\
    \x8f\x01\x14\x1c\n\r\n\x05\x04\x05\x02\x0b\x03\x12\x04\x8f\x01\x1f!\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
